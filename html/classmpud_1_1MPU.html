<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.6"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>MPU Drive: mpud::MPU Class Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">MPU Drive 1.0</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempud.html">mpud</a></li><li class="navelem"><a class="el" href="classmpud_1_1MPU.html">MPU</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmpud_1_1MPU-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mpud::MPU Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Motion Processing Unit.  
 <a href="classmpud_1_1MPU.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MPU_8hpp_source.html">MPU.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mpud::MPU:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmpud_1_1MPU.png" usemap="#mpud::MPU_map" alt=""/>
  <map id="mpud::MPU_map" name="mpud::MPU_map">
<area href="classmpud_1_1dmp_1_1MPUdmp.html" alt="mpud::dmp::MPUdmp" shape="rect" coords="0,56,127,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors / Destructor</div></td></tr>
<tr class="memitem:ae29b235301395c9842d962936ea96f95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ae29b235301395c9842d962936ea96f95">MPU</a> ()</td></tr>
<tr class="memdesc:ae29b235301395c9842d962936ea96f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="#ae29b235301395c9842d962936ea96f95">More...</a><br/></td></tr>
<tr class="separator:ae29b235301395c9842d962936ea96f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b67d15cdc0a41df0516fe350b6fb77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a89b67d15cdc0a41df0516fe350b6fb77">MPU</a> (mpu_bus_t &amp;<a class="el" href="classmpud_1_1MPU.html#a0f03e490201c43f19716f90eb9361c19">bus</a>)</td></tr>
<tr class="memdesc:a89b67d15cdc0a41df0516fe350b6fb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contruct a <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a> in the given communication bus.  <a href="#a89b67d15cdc0a41df0516fe350b6fb77">More...</a><br/></td></tr>
<tr class="separator:a89b67d15cdc0a41df0516fe350b6fb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04961949e7055540e5e94f3bd96901e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a04961949e7055540e5e94f3bd96901e1">MPU</a> (mpu_bus_t &amp;<a class="el" href="classmpud_1_1MPU.html#a0f03e490201c43f19716f90eb9361c19">bus</a>, mpu_addr_handle_t <a class="el" href="classmpud_1_1MPU.html#ab2b6d939170bf05316efd09e2b669dc1">addr</a>)</td></tr>
<tr class="memdesc:a04961949e7055540e5e94f3bd96901e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a> in the given communication bus and address.  <a href="#a04961949e7055540e5e94f3bd96901e1">More...</a><br/></td></tr>
<tr class="separator:a04961949e7055540e5e94f3bd96901e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4158daa85e9a1121cd8d042489ccdfb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a4158daa85e9a1121cd8d042489ccdfb3">~MPU</a> ()</td></tr>
<tr class="memdesc:a4158daa85e9a1121cd8d042489ccdfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Destructor, does nothing.  <a href="#a4158daa85e9a1121cd8d042489ccdfb3">More...</a><br/></td></tr>
<tr class="separator:a4158daa85e9a1121cd8d042489ccdfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic</div></td></tr>
<tr class="memitem:a6141d67b7fd4188b26832a4e15471940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpud_1_1MPU.html">MPU</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a6141d67b7fd4188b26832a4e15471940">setBus</a> (mpu_bus_t &amp;<a class="el" href="classmpud_1_1MPU.html#a0f03e490201c43f19716f90eb9361c19">bus</a>)</td></tr>
<tr class="memdesc:a6141d67b7fd4188b26832a4e15471940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set communication bus.  <a href="#a6141d67b7fd4188b26832a4e15471940">More...</a><br/></td></tr>
<tr class="separator:a6141d67b7fd4188b26832a4e15471940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239ee099bcc9d010622ab87e0309d742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpud_1_1MPU.html">MPU</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a239ee099bcc9d010622ab87e0309d742">setAddr</a> (mpu_addr_handle_t <a class="el" href="classmpud_1_1MPU.html#ab2b6d939170bf05316efd09e2b669dc1">addr</a>)</td></tr>
<tr class="memdesc:a239ee099bcc9d010622ab87e0309d742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C address or SPI device handle.  <a href="#a239ee099bcc9d010622ab87e0309d742">More...</a><br/></td></tr>
<tr class="separator:a239ee099bcc9d010622ab87e0309d742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a067ee1144f7fd2535d787174b34d2"><td class="memItemLeft" align="right" valign="top">mpu_bus_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ac5a067ee1144f7fd2535d787174b34d2">getBus</a> ()</td></tr>
<tr class="memdesc:ac5a067ee1144f7fd2535d787174b34d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return communication bus object.  <a href="#ac5a067ee1144f7fd2535d787174b34d2">More...</a><br/></td></tr>
<tr class="separator:ac5a067ee1144f7fd2535d787174b34d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbc68bfe24ba563917875239e8d5bca"><td class="memItemLeft" align="right" valign="top">mpu_addr_handle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a3bbc68bfe24ba563917875239e8d5bca">getAddr</a> ()</td></tr>
<tr class="memdesc:a3bbc68bfe24ba563917875239e8d5bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return I2C address or SPI device handle.  <a href="#a3bbc68bfe24ba563917875239e8d5bca">More...</a><br/></td></tr>
<tr class="separator:a3bbc68bfe24ba563917875239e8d5bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc571c795e7675a7e581e9de3132423"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a7dc571c795e7675a7e581e9de3132423">lastError</a> ()</td></tr>
<tr class="memdesc:a7dc571c795e7675a7e581e9de3132423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return last error code.  <a href="#a7dc571c795e7675a7e581e9de3132423">More...</a><br/></td></tr>
<tr class="separator:a7dc571c795e7675a7e581e9de3132423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Setup</div></td></tr>
<tr class="memitem:abf4ec47b5cddc47b1bf640d18f1f6e03"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#abf4ec47b5cddc47b1bf640d18f1f6e03">initialize</a> ()</td></tr>
<tr class="memdesc:abf4ec47b5cddc47b1bf640d18f1f6e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a> device and set basic configurations.  <a href="#abf4ec47b5cddc47b1bf640d18f1f6e03">More...</a><br/></td></tr>
<tr class="separator:abf4ec47b5cddc47b1bf640d18f1f6e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac816b0c7f9c347e96a4b87bf9280d366"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ac816b0c7f9c347e96a4b87bf9280d366">reset</a> ()</td></tr>
<tr class="memdesc:ac816b0c7f9c347e96a4b87bf9280d366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset internal registers and restore to default start-up state.  <a href="#ac816b0c7f9c347e96a4b87bf9280d366">More...</a><br/></td></tr>
<tr class="separator:ac816b0c7f9c347e96a4b87bf9280d366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ada26485f2936515d07dff156912ec"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a14ada26485f2936515d07dff156912ec">setSleep</a> (bool enable)</td></tr>
<tr class="memdesc:a14ada26485f2936515d07dff156912ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable sleep mode.  <a href="#a14ada26485f2936515d07dff156912ec">More...</a><br/></td></tr>
<tr class="separator:a14ada26485f2936515d07dff156912ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4b1566f17724e1e608357fee52e40e"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a6d4b1566f17724e1e608357fee52e40e">testConnection</a> ()</td></tr>
<tr class="memdesc:a6d4b1566f17724e1e608357fee52e40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test connection with <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a>.  <a href="#a6d4b1566f17724e1e608357fee52e40e">More...</a><br/></td></tr>
<tr class="separator:a6d4b1566f17724e1e608357fee52e40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ea9e17d5eded6f6fc1c571b5adf09a"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ab2ea9e17d5eded6f6fc1c571b5adf09a">selfTest</a> (selftest_t *result)</td></tr>
<tr class="memdesc:ab2ea9e17d5eded6f6fc1c571b5adf09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger gyro and accel hardware self-test.  <a href="#ab2ea9e17d5eded6f6fc1c571b5adf09a">More...</a><br/></td></tr>
<tr class="separator:ab2ea9e17d5eded6f6fc1c571b5adf09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c2fceb9b73753b7a1e64830eee2bff"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ad4c2fceb9b73753b7a1e64830eee2bff">resetSignalPath</a> ()</td></tr>
<tr class="memdesc:ad4c2fceb9b73753b7a1e64830eee2bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset sensors signal path.  <a href="#ad4c2fceb9b73753b7a1e64830eee2bff">More...</a><br/></td></tr>
<tr class="separator:ad4c2fceb9b73753b7a1e64830eee2bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfeba46e532569acefa3d7e4a1ad7c1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#afcfeba46e532569acefa3d7e4a1ad7c1">whoAmI</a> ()</td></tr>
<tr class="memdesc:afcfeba46e532569acefa3d7e4a1ad7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value from WHO_AM_I register.  <a href="#afcfeba46e532569acefa3d7e4a1ad7c1">More...</a><br/></td></tr>
<tr class="separator:afcfeba46e532569acefa3d7e4a1ad7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddfb49d62323ff4dd4d3b5dfc389217"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aeddfb49d62323ff4dd4d3b5dfc389217">getSleep</a> ()</td></tr>
<tr class="memdesc:aeddfb49d62323ff4dd4d3b5dfc389217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current sleep state.  <a href="#aeddfb49d62323ff4dd4d3b5dfc389217">More...</a><br/></td></tr>
<tr class="separator:aeddfb49d62323ff4dd4d3b5dfc389217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Main configurations</div></td></tr>
<tr class="memitem:a65cf0a938a17e4e6b81d9d4625e2d7f9"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a65cf0a938a17e4e6b81d9d4625e2d7f9">setSampleRate</a> (uint16_t rate)</td></tr>
<tr class="memdesc:a65cf0a938a17e4e6b81d9d4625e2d7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set sample rate of data output.  <a href="#a65cf0a938a17e4e6b81d9d4625e2d7f9">More...</a><br/></td></tr>
<tr class="separator:a65cf0a938a17e4e6b81d9d4625e2d7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af792064f923921167a1385197d18fb10"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#af792064f923921167a1385197d18fb10">setClockSource</a> (clock_src_t clockSrc)</td></tr>
<tr class="memdesc:af792064f923921167a1385197d18fb10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select clock source.  <a href="#af792064f923921167a1385197d18fb10">More...</a><br/></td></tr>
<tr class="separator:af792064f923921167a1385197d18fb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93430f192fea612abf036ba3729ba844"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a93430f192fea612abf036ba3729ba844">setDigitalLowPassFilter</a> (dlpf_t dlpf)</td></tr>
<tr class="memdesc:a93430f192fea612abf036ba3729ba844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures Digital Low Pass Filter (DLPF) setting for both the gyroscope and accelerometer.  <a href="#a93430f192fea612abf036ba3729ba844">More...</a><br/></td></tr>
<tr class="separator:a93430f192fea612abf036ba3729ba844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad100efa072bb68c2b910d5f7c8f01025"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ad100efa072bb68c2b910d5f7c8f01025">getSampleRate</a> ()</td></tr>
<tr class="memdesc:ad100efa072bb68c2b910d5f7c8f01025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve sample rate divider and calculate the actual rate.  <a href="#ad100efa072bb68c2b910d5f7c8f01025">More...</a><br/></td></tr>
<tr class="separator:ad100efa072bb68c2b910d5f7c8f01025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e837de0c4e3295b23fc3795a6d7a4c6"><td class="memItemLeft" align="right" valign="top">clock_src_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a0e837de0c4e3295b23fc3795a6d7a4c6">getClockSource</a> ()</td></tr>
<tr class="memdesc:a0e837de0c4e3295b23fc3795a6d7a4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return clock source.  <a href="#a0e837de0c4e3295b23fc3795a6d7a4c6">More...</a><br/></td></tr>
<tr class="separator:a0e837de0c4e3295b23fc3795a6d7a4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00fa4ebabb30fd38b8e5a934831c0a4"><td class="memItemLeft" align="right" valign="top">dlpf_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ab00fa4ebabb30fd38b8e5a934831c0a4">getDigitalLowPassFilter</a> ()</td></tr>
<tr class="memdesc:ab00fa4ebabb30fd38b8e5a934831c0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Digital Low Pass Filter configuration.  <a href="#ab00fa4ebabb30fd38b8e5a934831c0a4">More...</a><br/></td></tr>
<tr class="separator:ab00fa4ebabb30fd38b8e5a934831c0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Power management</div></td></tr>
<tr class="memitem:ae518ddb48624a5a9b664c3c86a2c2759"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ae518ddb48624a5a9b664c3c86a2c2759">setLowPowerAccelMode</a> (bool enable)</td></tr>
<tr class="memdesc:ae518ddb48624a5a9b664c3c86a2c2759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter Low Power Accelerometer mode.  <a href="#ae518ddb48624a5a9b664c3c86a2c2759">More...</a><br/></td></tr>
<tr class="separator:ae518ddb48624a5a9b664c3c86a2c2759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2886c024e5239d67ea8fff668e734d"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#afa2886c024e5239d67ea8fff668e734d">setLowPowerAccelRate</a> (lp_accel_rate_t rate)</td></tr>
<tr class="memdesc:afa2886c024e5239d67ea8fff668e734d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Low Power Accelerometer frequency of wake-up.  <a href="#afa2886c024e5239d67ea8fff668e734d">More...</a><br/></td></tr>
<tr class="separator:afa2886c024e5239d67ea8fff668e734d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ccd9930f45bf7d7f846669faaa6470"><td class="memItemLeft" align="right" valign="top">lp_accel_rate_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ab4ccd9930f45bf7d7f846669faaa6470">getLowPowerAccelRate</a> ()</td></tr>
<tr class="memdesc:ab4ccd9930f45bf7d7f846669faaa6470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Low Power Accelerometer frequency of wake-up.  <a href="#ab4ccd9930f45bf7d7f846669faaa6470">More...</a><br/></td></tr>
<tr class="separator:ab4ccd9930f45bf7d7f846669faaa6470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b209b83d102efbefa31652d7c7ab44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a06b209b83d102efbefa31652d7c7ab44">getLowPowerAccelMode</a> ()</td></tr>
<tr class="memdesc:a06b209b83d102efbefa31652d7c7ab44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Low Power Accelerometer state.  <a href="#a06b209b83d102efbefa31652d7c7ab44">More...</a><br/></td></tr>
<tr class="separator:a06b209b83d102efbefa31652d7c7ab44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd07ab02e86337b6bc0841c163320985"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#abd07ab02e86337b6bc0841c163320985">setStandbyMode</a> (stby_en_t mask)</td></tr>
<tr class="memdesc:abd07ab02e86337b6bc0841c163320985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure sensors' standby mode.  <a href="#abd07ab02e86337b6bc0841c163320985">More...</a><br/></td></tr>
<tr class="separator:abd07ab02e86337b6bc0841c163320985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5d207e7ac4d063af14c343acb25e6c"><td class="memItemLeft" align="right" valign="top">stby_en_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a4e5d207e7ac4d063af14c343acb25e6c">getStandbyMode</a> ()</td></tr>
<tr class="memdesc:a4e5d207e7ac4d063af14c343acb25e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Standby configuration.  <a href="#a4e5d207e7ac4d063af14c343acb25e6c">More...</a><br/></td></tr>
<tr class="separator:a4e5d207e7ac4d063af14c343acb25e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Full-Scale Range</div></td></tr>
<tr class="memitem:a2868752f20d013cb21e99ecd7592a05f"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a2868752f20d013cb21e99ecd7592a05f">setGyroFullScale</a> (gyro_fs_t fsr)</td></tr>
<tr class="memdesc:a2868752f20d013cb21e99ecd7592a05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select Gyroscope Full-scale range.  <a href="#a2868752f20d013cb21e99ecd7592a05f">More...</a><br/></td></tr>
<tr class="separator:a2868752f20d013cb21e99ecd7592a05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f50e9f28b6d5e0a03ab5d982b003d7d"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a8f50e9f28b6d5e0a03ab5d982b003d7d">setAccelFullScale</a> (accel_fs_t fsr)</td></tr>
<tr class="memdesc:a8f50e9f28b6d5e0a03ab5d982b003d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select Accelerometer Full-scale range.  <a href="#a8f50e9f28b6d5e0a03ab5d982b003d7d">More...</a><br/></td></tr>
<tr class="separator:a8f50e9f28b6d5e0a03ab5d982b003d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9617adda4ad6b567564530a4e30854ec"><td class="memItemLeft" align="right" valign="top">gyro_fs_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a9617adda4ad6b567564530a4e30854ec">getGyroFullScale</a> ()</td></tr>
<tr class="memdesc:a9617adda4ad6b567564530a4e30854ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Gyroscope Full-scale range.  <a href="#a9617adda4ad6b567564530a4e30854ec">More...</a><br/></td></tr>
<tr class="separator:a9617adda4ad6b567564530a4e30854ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b57a8867f81fa002cbd3a3e6f27a793"><td class="memItemLeft" align="right" valign="top">accel_fs_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a2b57a8867f81fa002cbd3a3e6f27a793">getAccelFullScale</a> ()</td></tr>
<tr class="memdesc:a2b57a8867f81fa002cbd3a3e6f27a793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Accelerometer Full-scale range.  <a href="#a2b57a8867f81fa002cbd3a3e6f27a793">More...</a><br/></td></tr>
<tr class="separator:a2b57a8867f81fa002cbd3a3e6f27a793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Offset / Bias</div></td></tr>
<tr class="memitem:aa4aae2cc95bdf261c87fcc8b5eb65af2"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aa4aae2cc95bdf261c87fcc8b5eb65af2">setGyroOffset</a> (raw_axes_t bias)</td></tr>
<tr class="memdesc:aa4aae2cc95bdf261c87fcc8b5eb65af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push biases to the gyro offset registers.  <a href="#aa4aae2cc95bdf261c87fcc8b5eb65af2">More...</a><br/></td></tr>
<tr class="separator:aa4aae2cc95bdf261c87fcc8b5eb65af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada55825eff00782af864b8eea324d148"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ada55825eff00782af864b8eea324d148">setAccelOffset</a> (raw_axes_t bias)</td></tr>
<tr class="memdesc:ada55825eff00782af864b8eea324d148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push biases to the accel offset registers.  <a href="#ada55825eff00782af864b8eea324d148">More...</a><br/></td></tr>
<tr class="separator:ada55825eff00782af864b8eea324d148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2370fc876d7f4e2f411d7a7e500a05f2"><td class="memItemLeft" align="right" valign="top">raw_axes_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a2370fc876d7f4e2f411d7a7e500a05f2">getGyroOffset</a> ()</td></tr>
<tr class="memdesc:a2370fc876d7f4e2f411d7a7e500a05f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return biases from the gyro offset registers.  <a href="#a2370fc876d7f4e2f411d7a7e500a05f2">More...</a><br/></td></tr>
<tr class="separator:a2370fc876d7f4e2f411d7a7e500a05f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ed2e3240d6e1c833a126dbdd40a3cf"><td class="memItemLeft" align="right" valign="top">raw_axes_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ad3ed2e3240d6e1c833a126dbdd40a3cf">getAccelOffset</a> ()</td></tr>
<tr class="memdesc:ad3ed2e3240d6e1c833a126dbdd40a3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return biases from accel offset registers.  <a href="#ad3ed2e3240d6e1c833a126dbdd40a3cf">More...</a><br/></td></tr>
<tr class="separator:ad3ed2e3240d6e1c833a126dbdd40a3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d921360cf1c516a0096dfa26997a12"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a90d921360cf1c516a0096dfa26997a12">computeOffsets</a> (raw_axes_t *accel, raw_axes_t *gyro)</td></tr>
<tr class="memdesc:a90d921360cf1c516a0096dfa26997a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Accelerometer and Gyroscope offsets.  <a href="#a90d921360cf1c516a0096dfa26997a12">More...</a><br/></td></tr>
<tr class="separator:a90d921360cf1c516a0096dfa26997a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Interrupt</div></td></tr>
<tr class="memitem:aca375de0ab565d6b29b3b5da05f4b784"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aca375de0ab565d6b29b3b5da05f4b784">setInterruptConfig</a> (int_config_t config)</td></tr>
<tr class="memdesc:aca375de0ab565d6b29b3b5da05f4b784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the Interrupt pin (INT).  <a href="#aca375de0ab565d6b29b3b5da05f4b784">More...</a><br/></td></tr>
<tr class="separator:aca375de0ab565d6b29b3b5da05f4b784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1c909c89a49e3b6c7916eaf94fd621"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a7d1c909c89a49e3b6c7916eaf94fd621">setInterruptEnabled</a> (int_en_t mask)</td></tr>
<tr class="memdesc:a7d1c909c89a49e3b6c7916eaf94fd621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable features to generate signal at Interrupt pin.  <a href="#a7d1c909c89a49e3b6c7916eaf94fd621">More...</a><br/></td></tr>
<tr class="separator:a7d1c909c89a49e3b6c7916eaf94fd621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09235a4fda5e67181f5955e144d650fe"><td class="memItemLeft" align="right" valign="top">int_stat_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a09235a4fda5e67181f5955e144d650fe">getInterruptStatus</a> ()</td></tr>
<tr class="memdesc:a09235a4fda5e67181f5955e144d650fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Interrupt status from INT_STATUS register.  <a href="#a09235a4fda5e67181f5955e144d650fe">More...</a><br/></td></tr>
<tr class="separator:a09235a4fda5e67181f5955e144d650fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b73dd1c899e8b8d49f01a51323f3aa"><td class="memItemLeft" align="right" valign="top">int_config_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a06b73dd1c899e8b8d49f01a51323f3aa">getInterruptConfig</a> ()</td></tr>
<tr class="memdesc:a06b73dd1c899e8b8d49f01a51323f3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Interrupt pin (INT) configuration.  <a href="#a06b73dd1c899e8b8d49f01a51323f3aa">More...</a><br/></td></tr>
<tr class="separator:a06b73dd1c899e8b8d49f01a51323f3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedabde55ce93c78db203d1691aed5387"><td class="memItemLeft" align="right" valign="top">int_en_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aedabde55ce93c78db203d1691aed5387">getInterruptEnabled</a> ()</td></tr>
<tr class="memdesc:aedabde55ce93c78db203d1691aed5387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return enabled features configured to generate signal at Interrupt pin.  <a href="#aedabde55ce93c78db203d1691aed5387">More...</a><br/></td></tr>
<tr class="separator:aedabde55ce93c78db203d1691aed5387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">FIFO</div></td></tr>
<tr class="memitem:af0e0ccb076f70cdb5cc0b60da43294c9"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#af0e0ccb076f70cdb5cc0b60da43294c9">setFIFOMode</a> (fifo_mode_t mode)</td></tr>
<tr class="memdesc:af0e0ccb076f70cdb5cc0b60da43294c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change FIFO mode.  <a href="#af0e0ccb076f70cdb5cc0b60da43294c9">More...</a><br/></td></tr>
<tr class="separator:af0e0ccb076f70cdb5cc0b60da43294c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccb3e80bee7ce275ce21c7d14658496"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aeccb3e80bee7ce275ce21c7d14658496">setFIFOConfig</a> (fifo_config_t config)</td></tr>
<tr class="memdesc:aeccb3e80bee7ce275ce21c7d14658496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the sensors that will be written to the FIFO.  <a href="#aeccb3e80bee7ce275ce21c7d14658496">More...</a><br/></td></tr>
<tr class="separator:aeccb3e80bee7ce275ce21c7d14658496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047d9014f1cbcdab1820e6e9ab398cf4"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a047d9014f1cbcdab1820e6e9ab398cf4">setFIFOEnabled</a> (bool enable)</td></tr>
<tr class="memdesc:a047d9014f1cbcdab1820e6e9ab398cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enabled / disable FIFO module.  <a href="#a047d9014f1cbcdab1820e6e9ab398cf4">More...</a><br/></td></tr>
<tr class="separator:a047d9014f1cbcdab1820e6e9ab398cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac179cdbbb90e610a235ebf5060511c94"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ac179cdbbb90e610a235ebf5060511c94">resetFIFO</a> ()</td></tr>
<tr class="memdesc:ac179cdbbb90e610a235ebf5060511c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset FIFO module.  <a href="#ac179cdbbb90e610a235ebf5060511c94">More...</a><br/></td></tr>
<tr class="separator:ac179cdbbb90e610a235ebf5060511c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0163f781232d7999de4b3d471f6166"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a0a0163f781232d7999de4b3d471f6166">getFIFOCount</a> ()</td></tr>
<tr class="memdesc:a0a0163f781232d7999de4b3d471f6166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of written bytes in the FIFO.  <a href="#a0a0163f781232d7999de4b3d471f6166">More...</a><br/></td></tr>
<tr class="separator:a0a0163f781232d7999de4b3d471f6166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada674500740290d24050a5977a278cf0"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ada674500740290d24050a5977a278cf0">readFIFO</a> (size_t length, uint8_t *data)</td></tr>
<tr class="memdesc:ada674500740290d24050a5977a278cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data contained in FIFO buffer.  <a href="#ada674500740290d24050a5977a278cf0">More...</a><br/></td></tr>
<tr class="separator:ada674500740290d24050a5977a278cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeeddc45a786735b611621d0cfe719b7"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aaeeddc45a786735b611621d0cfe719b7">writeFIFO</a> (size_t length, const uint8_t *data)</td></tr>
<tr class="memdesc:aaeeddc45a786735b611621d0cfe719b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to FIFO buffer.  <a href="#aaeeddc45a786735b611621d0cfe719b7">More...</a><br/></td></tr>
<tr class="separator:aaeeddc45a786735b611621d0cfe719b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e509f6284e00539cdb3745940902f73"><td class="memItemLeft" align="right" valign="top">fifo_mode_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a7e509f6284e00539cdb3745940902f73">getFIFOMode</a> ()</td></tr>
<tr class="memdesc:a7e509f6284e00539cdb3745940902f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return FIFO mode.  <a href="#a7e509f6284e00539cdb3745940902f73">More...</a><br/></td></tr>
<tr class="separator:a7e509f6284e00539cdb3745940902f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d2e8538b9bee088cd24a8ed96696f8"><td class="memItemLeft" align="right" valign="top">fifo_config_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a03d2e8538b9bee088cd24a8ed96696f8">getFIFOConfig</a> ()</td></tr>
<tr class="memdesc:a03d2e8538b9bee088cd24a8ed96696f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return FIFO configuration.  <a href="#a03d2e8538b9bee088cd24a8ed96696f8">More...</a><br/></td></tr>
<tr class="separator:a03d2e8538b9bee088cd24a8ed96696f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245641aa976568a0ef57ea8f5a455755"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a245641aa976568a0ef57ea8f5a455755">getFIFOEnabled</a> ()</td></tr>
<tr class="memdesc:a245641aa976568a0ef57ea8f5a455755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return FIFO module state.  <a href="#a245641aa976568a0ef57ea8f5a455755">More...</a><br/></td></tr>
<tr class="separator:a245641aa976568a0ef57ea8f5a455755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Auxiliary I2C Master</div></td></tr>
<tr class="memitem:a80fb7650a035eac4ca21c73af61584b9"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a80fb7650a035eac4ca21c73af61584b9">setAuxI2CConfig</a> (const auxi2c_config_t &amp;config)</td></tr>
<tr class="memdesc:a80fb7650a035eac4ca21c73af61584b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the Auxiliary I2C Master.  <a href="#a80fb7650a035eac4ca21c73af61584b9">More...</a><br/></td></tr>
<tr class="separator:a80fb7650a035eac4ca21c73af61584b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc70b0f6fbbc924458fbea7a6a4e445"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a7dc70b0f6fbbc924458fbea7a6a4e445">setAuxI2CEnabled</a> (bool enable)</td></tr>
<tr class="memdesc:a7dc70b0f6fbbc924458fbea7a6a4e445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable Auxiliary I2C Master module.  <a href="#a7dc70b0f6fbbc924458fbea7a6a4e445">More...</a><br/></td></tr>
<tr class="separator:a7dc70b0f6fbbc924458fbea7a6a4e445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d59d8d47005a54d3b596aa95ae6ecb5"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a5d59d8d47005a54d3b596aa95ae6ecb5">setAuxI2CSlaveConfig</a> (const auxi2c_slv_config_t &amp;config)</td></tr>
<tr class="memdesc:a5d59d8d47005a54d3b596aa95ae6ecb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure communication with a Slave connected to Auxiliary I2C bus.  <a href="#a5d59d8d47005a54d3b596aa95ae6ecb5">More...</a><br/></td></tr>
<tr class="separator:a5d59d8d47005a54d3b596aa95ae6ecb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0daae48cac088da3f3f82472fd56410"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ae0daae48cac088da3f3f82472fd56410">setAuxI2CSlaveEnabled</a> (auxi2c_slv_t slave, bool enable)</td></tr>
<tr class="memdesc:ae0daae48cac088da3f3f82472fd56410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the Auxiliary I2C module to transfer data with a slave at sample rate.  <a href="#ae0daae48cac088da3f3f82472fd56410">More...</a><br/></td></tr>
<tr class="separator:ae0daae48cac088da3f3f82472fd56410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234737d60a59bc91847e8c1efc09d0d4"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a234737d60a59bc91847e8c1efc09d0d4">setAuxI2CBypass</a> (bool enable)</td></tr>
<tr class="memdesc:a234737d60a59bc91847e8c1efc09d0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable Auxiliary I2C bypass mode.  <a href="#a234737d60a59bc91847e8c1efc09d0d4">More...</a><br/></td></tr>
<tr class="separator:a234737d60a59bc91847e8c1efc09d0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11434db963024c65bbc2d1af0adcdcf"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#af11434db963024c65bbc2d1af0adcdcf">readAuxI2CRxData</a> (size_t length, uint8_t *data, size_t skip=0)</td></tr>
<tr class="memdesc:af11434db963024c65bbc2d1af0adcdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from slaves connected to Auxiliar I2C bus.  <a href="#af11434db963024c65bbc2d1af0adcdcf">More...</a><br/></td></tr>
<tr class="separator:af11434db963024c65bbc2d1af0adcdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50185e00fdc4f8cc0eda07237413a0c"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ae50185e00fdc4f8cc0eda07237413a0c">restartAuxI2C</a> ()</td></tr>
<tr class="memdesc:ae50185e00fdc4f8cc0eda07237413a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart Auxiliary I2C Master module, reset is asynchronous.  <a href="#ae50185e00fdc4f8cc0eda07237413a0c">More...</a><br/></td></tr>
<tr class="separator:ae50185e00fdc4f8cc0eda07237413a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc5f97dd6e1540a8f61fb5cc38f3b1d"><td class="memItemLeft" align="right" valign="top">auxi2c_stat_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a8fc5f97dd6e1540a8f61fb5cc38f3b1d">getAuxI2CStatus</a> ()</td></tr>
<tr class="memdesc:a8fc5f97dd6e1540a8f61fb5cc38f3b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Auxiliary I2C Master status from register I2C_MST_STATUS.  <a href="#a8fc5f97dd6e1540a8f61fb5cc38f3b1d">More...</a><br/></td></tr>
<tr class="separator:a8fc5f97dd6e1540a8f61fb5cc38f3b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b707dd2b97ebbeae3b8fe77b8f9892"><td class="memItemLeft" align="right" valign="top">auxi2c_config_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a31b707dd2b97ebbeae3b8fe77b8f9892">getAuxI2CConfig</a> ()</td></tr>
<tr class="memdesc:a31b707dd2b97ebbeae3b8fe77b8f9892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Auxiliary I2C Master configuration.  <a href="#a31b707dd2b97ebbeae3b8fe77b8f9892">More...</a><br/></td></tr>
<tr class="separator:a31b707dd2b97ebbeae3b8fe77b8f9892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec47c3742cd89130e8d4952a91ba965"><td class="memItemLeft" align="right" valign="top">auxi2c_slv_config_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a3ec47c3742cd89130e8d4952a91ba965">getAuxI2CSlaveConfig</a> (auxi2c_slv_t slave)</td></tr>
<tr class="memdesc:a3ec47c3742cd89130e8d4952a91ba965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return configuration of a Aux I2C Slave.  <a href="#a3ec47c3742cd89130e8d4952a91ba965">More...</a><br/></td></tr>
<tr class="separator:a3ec47c3742cd89130e8d4952a91ba965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66b29fca8dc95046925cd0fb834c3ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ac66b29fca8dc95046925cd0fb834c3ac">getAuxI2CEnabled</a> ()</td></tr>
<tr class="memdesc:ac66b29fca8dc95046925cd0fb834c3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Auxiliary I2C Master state.  <a href="#ac66b29fca8dc95046925cd0fb834c3ac">More...</a><br/></td></tr>
<tr class="separator:ac66b29fca8dc95046925cd0fb834c3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1fbbbcab82a4894fb91cbfd8452dff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aae1fbbbcab82a4894fb91cbfd8452dff">getAuxI2CSlaveEnabled</a> (auxi2c_slv_t slave)</td></tr>
<tr class="memdesc:aae1fbbbcab82a4894fb91cbfd8452dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return enable state of a Aux I2C's Slave.  <a href="#aae1fbbbcab82a4894fb91cbfd8452dff">More...</a><br/></td></tr>
<tr class="separator:aae1fbbbcab82a4894fb91cbfd8452dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16214d20e471966b8310889382e6245c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a16214d20e471966b8310889382e6245c">getAuxI2CBypass</a> ()</td></tr>
<tr class="memdesc:a16214d20e471966b8310889382e6245c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Auxiliary I2C Master bypass mode state.  <a href="#a16214d20e471966b8310889382e6245c">More...</a><br/></td></tr>
<tr class="separator:a16214d20e471966b8310889382e6245c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68de8f658162f624f0f6437b4b00663"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ab68de8f658162f624f0f6437b4b00663">auxI2CWriteByte</a> (uint8_t devAddr, uint8_t regAddr, uint8_t data)</td></tr>
<tr class="memdesc:ab68de8f658162f624f0f6437b4b00663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a slave a single byte just once (use for configuring a slave at initialization).  <a href="#ab68de8f658162f624f0f6437b4b00663">More...</a><br/></td></tr>
<tr class="separator:ab68de8f658162f624f0f6437b4b00663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e1c9a1392f875e03144145b3647e8e"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aa3e1c9a1392f875e03144145b3647e8e">auxI2CReadByte</a> (uint8_t devAddr, uint8_t regAddr, uint8_t *data)</td></tr>
<tr class="memdesc:aa3e1c9a1392f875e03144145b3647e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single byte frome slave just once (use for configuring a slave at initialization).  <a href="#aa3e1c9a1392f875e03144145b3647e8e">More...</a><br/></td></tr>
<tr class="separator:aa3e1c9a1392f875e03144145b3647e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Motion Detection Interrupt</div></td></tr>
<tr class="memitem:a4f964bb09777e246ab9bc868c7b52ae0"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a4f964bb09777e246ab9bc868c7b52ae0">setMotionDetectConfig</a> (mot_config_t &amp;config)</td></tr>
<tr class="memdesc:a4f964bb09777e246ab9bc868c7b52ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure Motion-Detect or Wake-on-motion feature.  <a href="#a4f964bb09777e246ab9bc868c7b52ae0">More...</a><br/></td></tr>
<tr class="separator:a4f964bb09777e246ab9bc868c7b52ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7ddfc203bfcad9526fe44b126cf558"><td class="memItemLeft" align="right" valign="top">mot_config_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a8b7ddfc203bfcad9526fe44b126cf558">getMotionDetectConfig</a> ()</td></tr>
<tr class="memdesc:a8b7ddfc203bfcad9526fe44b126cf558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Motion Detection Configuration.  <a href="#a8b7ddfc203bfcad9526fe44b126cf558">More...</a><br/></td></tr>
<tr class="separator:a8b7ddfc203bfcad9526fe44b126cf558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79f7156514ab8f38db1dba7e3ee2931"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aa79f7156514ab8f38db1dba7e3ee2931">setMotionFeatureEnabled</a> (bool enable)</td></tr>
<tr class="memdesc:aa79f7156514ab8f38db1dba7e3ee2931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable Motion modules (Motion detect, Zero-motion, Free-Fall).  <a href="#aa79f7156514ab8f38db1dba7e3ee2931">More...</a><br/></td></tr>
<tr class="separator:aa79f7156514ab8f38db1dba7e3ee2931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9be65d55d154aed34bd6d24858c6b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a7e9be65d55d154aed34bd6d24858c6b8">getMotionFeatureEnabled</a> ()</td></tr>
<tr class="memdesc:a7e9be65d55d154aed34bd6d24858c6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a Motion Dectection module is enabled.  <a href="#a7e9be65d55d154aed34bd6d24858c6b8">More...</a><br/></td></tr>
<tr class="separator:a7e9be65d55d154aed34bd6d24858c6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8098999b567e7352b7150df5197f28ce"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a8098999b567e7352b7150df5197f28ce">setZeroMotionConfig</a> (zrmot_config_t &amp;config)</td></tr>
<tr class="memdesc:a8098999b567e7352b7150df5197f28ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure Zero-Motion.  <a href="#a8098999b567e7352b7150df5197f28ce">More...</a><br/></td></tr>
<tr class="separator:a8098999b567e7352b7150df5197f28ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc14bfa64a079c9fa9cdc0754bc6a6ef"><td class="memItemLeft" align="right" valign="top">zrmot_config_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#acc14bfa64a079c9fa9cdc0754bc6a6ef">getZeroMotionConfig</a> ()</td></tr>
<tr class="memdesc:acc14bfa64a079c9fa9cdc0754bc6a6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Zero-Motion configuration.  <a href="#acc14bfa64a079c9fa9cdc0754bc6a6ef">More...</a><br/></td></tr>
<tr class="separator:acc14bfa64a079c9fa9cdc0754bc6a6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5de2361bde9aff3cbd069dfa319ca11"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ad5de2361bde9aff3cbd069dfa319ca11">setFreeFallConfig</a> (ff_config_t &amp;config)</td></tr>
<tr class="memdesc:ad5de2361bde9aff3cbd069dfa319ca11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure Free-Fall.  <a href="#ad5de2361bde9aff3cbd069dfa319ca11">More...</a><br/></td></tr>
<tr class="separator:ad5de2361bde9aff3cbd069dfa319ca11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5928c0ec1dced316a4cc97b65f8bf1"><td class="memItemLeft" align="right" valign="top">ff_config_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a3f5928c0ec1dced316a4cc97b65f8bf1">getFreeFallConfig</a> ()</td></tr>
<tr class="memdesc:a3f5928c0ec1dced316a4cc97b65f8bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Free-Fall Configuration.  <a href="#a3f5928c0ec1dced316a4cc97b65f8bf1">More...</a><br/></td></tr>
<tr class="separator:a3f5928c0ec1dced316a4cc97b65f8bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690d1e11d03a37182c6c82685e86614e"><td class="memItemLeft" align="right" valign="top">mot_stat_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a690d1e11d03a37182c6c82685e86614e">getMotionDetectStatus</a> ()</td></tr>
<tr class="memdesc:a690d1e11d03a37182c6c82685e86614e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Motion Detection Status.  <a href="#a690d1e11d03a37182c6c82685e86614e">More...</a><br/></td></tr>
<tr class="separator:a690d1e11d03a37182c6c82685e86614e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Compass | Magnetometer</div></td></tr>
<tr class="memitem:ad630f8c5b4530723a71e299c66403f58"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ad630f8c5b4530723a71e299c66403f58">compassInit</a> ()</td></tr>
<tr class="memdesc:ad630f8c5b4530723a71e299c66403f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Magnetometer sensor.  <a href="#ad630f8c5b4530723a71e299c66403f58">More...</a><br/></td></tr>
<tr class="separator:ad630f8c5b4530723a71e299c66403f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c7fca29923e1e1b0938df3d5162802"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a72c7fca29923e1e1b0938df3d5162802">compassTestConnection</a> ()</td></tr>
<tr class="memdesc:a72c7fca29923e1e1b0938df3d5162802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test connection with Magnetometer by checking WHO_I_AM register.  <a href="#a72c7fca29923e1e1b0938df3d5162802">More...</a><br/></td></tr>
<tr class="separator:a72c7fca29923e1e1b0938df3d5162802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d2ede5f5efb04d571887294009984b"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a48d2ede5f5efb04d571887294009984b">compassSetMode</a> (mag_mode_t mode)</td></tr>
<tr class="memdesc:a48d2ede5f5efb04d571887294009984b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change magnetometer's measurement mode.  <a href="#a48d2ede5f5efb04d571887294009984b">More...</a><br/></td></tr>
<tr class="separator:a48d2ede5f5efb04d571887294009984b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce2b215567a244643f12c777d4cd2fc"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#abce2b215567a244643f12c777d4cd2fc">compassGetAdjustment</a> (uint8_t *x, uint8_t *y, uint8_t *z)</td></tr>
<tr class="memdesc:abce2b215567a244643f12c777d4cd2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Magnetometer's sensitivity adjustment data for each axis.  <a href="#abce2b215567a244643f12c777d4cd2fc">More...</a><br/></td></tr>
<tr class="separator:abce2b215567a244643f12c777d4cd2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93c745f1e13880e5b8b76f67348654b"><td class="memItemLeft" align="right" valign="top">mag_mode_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ad93c745f1e13880e5b8b76f67348654b">compassGetMode</a> ()</td></tr>
<tr class="memdesc:ad93c745f1e13880e5b8b76f67348654b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return magnetometer's measurement mode.  <a href="#ad93c745f1e13880e5b8b76f67348654b">More...</a><br/></td></tr>
<tr class="separator:ad93c745f1e13880e5b8b76f67348654b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f6872c40bbe0a2d697788816f3fd43"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a29f6872c40bbe0a2d697788816f3fd43">compassWhoAmI</a> ()</td></tr>
<tr class="memdesc:a29f6872c40bbe0a2d697788816f3fd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value from WHO_I_AM register.  <a href="#a29f6872c40bbe0a2d697788816f3fd43">More...</a><br/></td></tr>
<tr class="separator:a29f6872c40bbe0a2d697788816f3fd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4f070f64dfc38a228e57da16ed989f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ace4f070f64dfc38a228e57da16ed989f">compassGetInfo</a> ()</td></tr>
<tr class="memdesc:ace4f070f64dfc38a228e57da16ed989f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value from magnetometer's INFO register.  <a href="#ace4f070f64dfc38a228e57da16ed989f">More...</a><br/></td></tr>
<tr class="separator:ace4f070f64dfc38a228e57da16ed989f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a6478e08168bdb203fd5461ab5ee54"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a89a6478e08168bdb203fd5461ab5ee54">compassReadByte</a> (uint8_t regAddr, uint8_t *data)</td></tr>
<tr class="memdesc:a89a6478e08168bdb203fd5461ab5ee54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single byte from magnetometer.  <a href="#a89a6478e08168bdb203fd5461ab5ee54">More...</a><br/></td></tr>
<tr class="separator:a89a6478e08168bdb203fd5461ab5ee54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfb188d4068287d2cb47868c24ffde6"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aecfb188d4068287d2cb47868c24ffde6">compassWriteByte</a> (uint8_t regAddr, uint8_t data)</td></tr>
<tr class="memdesc:aecfb188d4068287d2cb47868c24ffde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single byte to magnetometer.  <a href="#aecfb188d4068287d2cb47868c24ffde6">More...</a><br/></td></tr>
<tr class="separator:aecfb188d4068287d2cb47868c24ffde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b7bde480912722eae7ae74969eb8b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aa8b7bde480912722eae7ae74969eb8b2">compassSelfTest</a> (raw_axes_t *result=nullptr)</td></tr>
<tr class="memdesc:aa8b7bde480912722eae7ae74969eb8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform Compass self-test.  <a href="#aa8b7bde480912722eae7ae74969eb8b2">More...</a><br/></td></tr>
<tr class="separator:aa8b7bde480912722eae7ae74969eb8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae438a779cc34c2ba9ad82c816d68cf67"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ae438a779cc34c2ba9ad82c816d68cf67">compassReset</a> ()</td></tr>
<tr class="memdesc:ae438a779cc34c2ba9ad82c816d68cf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Soft reset AK8963.  <a href="#ae438a779cc34c2ba9ad82c816d68cf67">More...</a><br/></td></tr>
<tr class="separator:ae438a779cc34c2ba9ad82c816d68cf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb1c4afbadabed3d5d730a494fc2f8f"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#afbb1c4afbadabed3d5d730a494fc2f8f">compassSetSensitivity</a> (mag_sensy_t sensy)</td></tr>
<tr class="memdesc:afbb1c4afbadabed3d5d730a494fc2f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set magnetometer sensitivity.  <a href="#afbb1c4afbadabed3d5d730a494fc2f8f">More...</a><br/></td></tr>
<tr class="separator:afbb1c4afbadabed3d5d730a494fc2f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08816e89273e50e065cf0fe9dbb6cc1"><td class="memItemLeft" align="right" valign="top">mag_sensy_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ad08816e89273e50e065cf0fe9dbb6cc1">compassGetSensitivity</a> ()</td></tr>
<tr class="memdesc:ad08816e89273e50e065cf0fe9dbb6cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return magnetometer sensitivity.  <a href="#ad08816e89273e50e065cf0fe9dbb6cc1">More...</a><br/></td></tr>
<tr class="separator:ad08816e89273e50e065cf0fe9dbb6cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous</div></td></tr>
<tr class="memitem:ae8ad215220b07819692624334ce6d4d8"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ae8ad215220b07819692624334ce6d4d8">setFsyncConfig</a> (int_lvl_t level)</td></tr>
<tr class="memdesc:ae8ad215220b07819692624334ce6d4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the active level of FSYNC pin that will cause an interrupt.  <a href="#ae8ad215220b07819692624334ce6d4d8">More...</a><br/></td></tr>
<tr class="separator:ae8ad215220b07819692624334ce6d4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d3408f13d9889c719d31bf3b59b316"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aa2d3408f13d9889c719d31bf3b59b316">setFsyncEnabled</a> (bool enable)</td></tr>
<tr class="memdesc:aa2d3408f13d9889c719d31bf3b59b316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable FSYNC pin to cause an interrupt.  <a href="#aa2d3408f13d9889c719d31bf3b59b316">More...</a><br/></td></tr>
<tr class="separator:aa2d3408f13d9889c719d31bf3b59b316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2482624d04492e84647953469dce5cd"><td class="memItemLeft" align="right" valign="top">int_lvl_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ad2482624d04492e84647953469dce5cd">getFsyncConfig</a> ()</td></tr>
<tr class="memdesc:ad2482624d04492e84647953469dce5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return FSYNC pin active level configuration.  <a href="#ad2482624d04492e84647953469dce5cd">More...</a><br/></td></tr>
<tr class="separator:ad2482624d04492e84647953469dce5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bafda6d35ea1b84f689b61b93f3459"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a98bafda6d35ea1b84f689b61b93f3459">getFsyncEnabled</a> ()</td></tr>
<tr class="memdesc:a98bafda6d35ea1b84f689b61b93f3459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return FSYNC enable state.  <a href="#a98bafda6d35ea1b84f689b61b93f3459">More...</a><br/></td></tr>
<tr class="separator:a98bafda6d35ea1b84f689b61b93f3459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef778fb0d9363b3a473ed87270fb0af"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a3ef778fb0d9363b3a473ed87270fb0af">setFchoice</a> (fchoice_t fchoice)</td></tr>
<tr class="memdesc:a3ef778fb0d9363b3a473ed87270fb0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select FCHOICE.  <a href="#a3ef778fb0d9363b3a473ed87270fb0af">More...</a><br/></td></tr>
<tr class="separator:a3ef778fb0d9363b3a473ed87270fb0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16889bbacbe873f5c8c5c7f0a64c1ec2"><td class="memItemLeft" align="right" valign="top">fchoice_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a16889bbacbe873f5c8c5c7f0a64c1ec2">getFchoice</a> ()</td></tr>
<tr class="memdesc:a16889bbacbe873f5c8c5c7f0a64c1ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return FCHOICE.  <a href="#a16889bbacbe873f5c8c5c7f0a64c1ec2">More...</a><br/></td></tr>
<tr class="separator:a16889bbacbe873f5c8c5c7f0a64c1ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfad2954a2039babb7a47e249858b34"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aedfad2954a2039babb7a47e249858b34">setAuxVDDIOLevel</a> (auxvddio_lvl_t level)</td></tr>
<tr class="memdesc:aedfad2954a2039babb7a47e249858b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MPU-6050’s I/O logic levels are set to be either VDD or VLOGIC.  <a href="#aedfad2954a2039babb7a47e249858b34">More...</a><br/></td></tr>
<tr class="separator:aedfad2954a2039babb7a47e249858b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e7f255e90a2238dfc174a4f9fb6f78"><td class="memItemLeft" align="right" valign="top">auxvddio_lvl_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ab7e7f255e90a2238dfc174a4f9fb6f78">getAuxVDDIOLevel</a> ()</td></tr>
<tr class="memdesc:ab7e7f255e90a2238dfc174a4f9fb6f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return MPU-6050’s I/O logic levels.  <a href="#ab7e7f255e90a2238dfc174a4f9fb6f78">More...</a><br/></td></tr>
<tr class="separator:ab7e7f255e90a2238dfc174a4f9fb6f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Read / Write</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Functions to perform direct read or write operation(s) to registers. </p>
</div></td></tr>
<tr class="memitem:a2ae96fcd85fb8984a648a537652628aa"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a2ae96fcd85fb8984a648a537652628aa">readBit</a> (uint8_t regAddr, uint8_t bitNum, uint8_t *data)</td></tr>
<tr class="memdesc:a2ae96fcd85fb8984a648a537652628aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single bit from a register.  <a href="#a2ae96fcd85fb8984a648a537652628aa">More...</a><br/></td></tr>
<tr class="separator:a2ae96fcd85fb8984a648a537652628aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72149421a41df3c7a3a4834262d96799"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a72149421a41df3c7a3a4834262d96799">readBits</a> (uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t *data)</td></tr>
<tr class="memdesc:a72149421a41df3c7a3a4834262d96799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a range of bits from a register.  <a href="#a72149421a41df3c7a3a4834262d96799">More...</a><br/></td></tr>
<tr class="separator:a72149421a41df3c7a3a4834262d96799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d8b3b65e360bad7cf0ef9303e060df"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ad3d8b3b65e360bad7cf0ef9303e060df">readByte</a> (uint8_t regAddr, uint8_t *data)</td></tr>
<tr class="memdesc:ad3d8b3b65e360bad7cf0ef9303e060df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single register.  <a href="#ad3d8b3b65e360bad7cf0ef9303e060df">More...</a><br/></td></tr>
<tr class="separator:ad3d8b3b65e360bad7cf0ef9303e060df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab105d924a8077595f55ef639ffd49c54"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ab105d924a8077595f55ef639ffd49c54">readBytes</a> (uint8_t regAddr, size_t length, uint8_t *data)</td></tr>
<tr class="memdesc:ab105d924a8077595f55ef639ffd49c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from sequence of registers.  <a href="#ab105d924a8077595f55ef639ffd49c54">More...</a><br/></td></tr>
<tr class="separator:ab105d924a8077595f55ef639ffd49c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad210960077fdbfacd7fa43ba3ca583b4"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ad210960077fdbfacd7fa43ba3ca583b4">writeBit</a> (uint8_t regAddr, uint8_t bitNum, uint8_t data)</td></tr>
<tr class="memdesc:ad210960077fdbfacd7fa43ba3ca583b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single bit to a register.  <a href="#ad210960077fdbfacd7fa43ba3ca583b4">More...</a><br/></td></tr>
<tr class="separator:ad210960077fdbfacd7fa43ba3ca583b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f18f4b076105c2c3f9ca4fcdf08f1a"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a84f18f4b076105c2c3f9ca4fcdf08f1a">writeBits</a> (uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data)</td></tr>
<tr class="memdesc:a84f18f4b076105c2c3f9ca4fcdf08f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a range of bits to a register.  <a href="#a84f18f4b076105c2c3f9ca4fcdf08f1a">More...</a><br/></td></tr>
<tr class="separator:a84f18f4b076105c2c3f9ca4fcdf08f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a288c09a9da20cbc1e6d3c9597fe42"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a79a288c09a9da20cbc1e6d3c9597fe42">writeByte</a> (uint8_t regAddr, uint8_t data)</td></tr>
<tr class="memdesc:a79a288c09a9da20cbc1e6d3c9597fe42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a register.  <a href="#a79a288c09a9da20cbc1e6d3c9597fe42">More...</a><br/></td></tr>
<tr class="separator:a79a288c09a9da20cbc1e6d3c9597fe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6ae433dba53a49ee7cc9c239784dff"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aea6ae433dba53a49ee7cc9c239784dff">writeBytes</a> (uint8_t regAddr, size_t length, const uint8_t *data)</td></tr>
<tr class="memdesc:aea6ae433dba53a49ee7cc9c239784dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a sequence to data to a sequence of registers.  <a href="#aea6ae433dba53a49ee7cc9c239784dff">More...</a><br/></td></tr>
<tr class="separator:aea6ae433dba53a49ee7cc9c239784dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c78483b51cade734c6aa4d0c1ba4260"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a0c78483b51cade734c6aa4d0c1ba4260">registerDump</a> (uint8_t start=0x0, uint8_t end=0x7F)</td></tr>
<tr class="memdesc:a0c78483b51cade734c6aa4d0c1ba4260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out register values for debugging purposes.  <a href="#a0c78483b51cade734c6aa4d0c1ba4260">More...</a><br/></td></tr>
<tr class="separator:a0c78483b51cade734c6aa4d0c1ba4260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sensor readings</div></td></tr>
<tr class="memitem:a2cbd3a9a7e3ba89f010db63603553502"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a2cbd3a9a7e3ba89f010db63603553502">acceleration</a> (raw_axes_t *accel)</td></tr>
<tr class="memdesc:a2cbd3a9a7e3ba89f010db63603553502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read accelerometer raw data.  <a href="#a2cbd3a9a7e3ba89f010db63603553502">More...</a><br/></td></tr>
<tr class="separator:a2cbd3a9a7e3ba89f010db63603553502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e61ca6aeabdab1c16d22e13100110c"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a07e61ca6aeabdab1c16d22e13100110c">acceleration</a> (int16_t *x, int16_t *y, int16_t *z)</td></tr>
<tr class="memdesc:a07e61ca6aeabdab1c16d22e13100110c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read accelerometer raw data.  <a href="#a07e61ca6aeabdab1c16d22e13100110c">More...</a><br/></td></tr>
<tr class="separator:a07e61ca6aeabdab1c16d22e13100110c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3867483a0ab5e6ad49d244f5c5bc7b"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a9a3867483a0ab5e6ad49d244f5c5bc7b">rotation</a> (raw_axes_t *gyro)</td></tr>
<tr class="memdesc:a9a3867483a0ab5e6ad49d244f5c5bc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read gyroscope raw data.  <a href="#a9a3867483a0ab5e6ad49d244f5c5bc7b">More...</a><br/></td></tr>
<tr class="separator:a9a3867483a0ab5e6ad49d244f5c5bc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f2053319e684514aab21f93964195b"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#aa9f2053319e684514aab21f93964195b">rotation</a> (int16_t *x, int16_t *y, int16_t *z)</td></tr>
<tr class="memdesc:aa9f2053319e684514aab21f93964195b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read gyroscope raw data.  <a href="#aa9f2053319e684514aab21f93964195b">More...</a><br/></td></tr>
<tr class="separator:aa9f2053319e684514aab21f93964195b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae90cd70c7a5d52bc4e591153348e91"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#abae90cd70c7a5d52bc4e591153348e91">temperature</a> (int16_t *temp)</td></tr>
<tr class="memdesc:abae90cd70c7a5d52bc4e591153348e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read temperature raw data.  <a href="#abae90cd70c7a5d52bc4e591153348e91">More...</a><br/></td></tr>
<tr class="separator:abae90cd70c7a5d52bc4e591153348e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10cea57d72889dfaec9d4945458fd26"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ae10cea57d72889dfaec9d4945458fd26">motion</a> (raw_axes_t *accel, raw_axes_t *gyro)</td></tr>
<tr class="memdesc:ae10cea57d72889dfaec9d4945458fd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read accelerometer and gyroscope data at once.  <a href="#ae10cea57d72889dfaec9d4945458fd26">More...</a><br/></td></tr>
<tr class="separator:ae10cea57d72889dfaec9d4945458fd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd6954c3a01beef7a20412d081ea52d"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a3dd6954c3a01beef7a20412d081ea52d">heading</a> (raw_axes_t *mag)</td></tr>
<tr class="memdesc:a3dd6954c3a01beef7a20412d081ea52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read compass data.  <a href="#a3dd6954c3a01beef7a20412d081ea52d">More...</a><br/></td></tr>
<tr class="separator:a3dd6954c3a01beef7a20412d081ea52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e22412e9a313663a3f0489f6e90c6d0"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a8e22412e9a313663a3f0489f6e90c6d0">heading</a> (int16_t *x, int16_t *y, int16_t *z)</td></tr>
<tr class="memdesc:a8e22412e9a313663a3f0489f6e90c6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read compass data.  <a href="#a8e22412e9a313663a3f0489f6e90c6d0">More...</a><br/></td></tr>
<tr class="separator:a8e22412e9a313663a3f0489f6e90c6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4984659aea9520de50c63732683cca"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a4e4984659aea9520de50c63732683cca">motion</a> (raw_axes_t *accel, raw_axes_t *gyro, raw_axes_t *mag)</td></tr>
<tr class="memdesc:a4e4984659aea9520de50c63732683cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read accelerometer, gyroscope, compass raw data.  <a href="#a4e4984659aea9520de50c63732683cca">More...</a><br/></td></tr>
<tr class="separator:a4e4984659aea9520de50c63732683cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5706267bee5220d4003968a1d03c26d9"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a5706267bee5220d4003968a1d03c26d9">sensors</a> (raw_axes_t *accel, raw_axes_t *gyro, int16_t *temp)</td></tr>
<tr class="memdesc:a5706267bee5220d4003968a1d03c26d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from all internal sensors.  <a href="#a5706267bee5220d4003968a1d03c26d9">More...</a><br/></td></tr>
<tr class="separator:a5706267bee5220d4003968a1d03c26d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248f2e18edc94d307fda175669659951"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a248f2e18edc94d307fda175669659951">sensors</a> (sensors_t *sensors, size_t extsens_len=0)</td></tr>
<tr class="memdesc:a248f2e18edc94d307fda175669659951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from all sensors, including external sensors in Aux I2C.  <a href="#a248f2e18edc94d307fda175669659951">More...</a><br/></td></tr>
<tr class="separator:a248f2e18edc94d307fda175669659951"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7abdca74a2aa34f8aa3f89e4399a7d35"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a7abdca74a2aa34f8aa3f89e4399a7d35">accelSelfTest</a> (raw_axes_t &amp;regularBias, raw_axes_t &amp;selfTestBias, uint8_t *result)</td></tr>
<tr class="memdesc:a7abdca74a2aa34f8aa3f89e4399a7d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accel Self-test.  <a href="#a7abdca74a2aa34f8aa3f89e4399a7d35">More...</a><br/></td></tr>
<tr class="separator:a7abdca74a2aa34f8aa3f89e4399a7d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccea2636c90a078bd5101ad0e5d463a"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a8ccea2636c90a078bd5101ad0e5d463a">gyroSelfTest</a> (raw_axes_t &amp;regularBias, raw_axes_t &amp;selfTestBias, uint8_t *result)</td></tr>
<tr class="memdesc:a8ccea2636c90a078bd5101ad0e5d463a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gyro Self-test.  <a href="#a8ccea2636c90a078bd5101ad0e5d463a">More...</a><br/></td></tr>
<tr class="separator:a8ccea2636c90a078bd5101ad0e5d463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b135cd444c2970e16ee8f967399b367"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a2b135cd444c2970e16ee8f967399b367">getBiases</a> (accel_fs_t accelFS, gyro_fs_t gyroFS, raw_axes_t *accelBias, raw_axes_t *gyroBias, bool selftest)</td></tr>
<tr class="memdesc:a2b135cd444c2970e16ee8f967399b367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Biases in regular mode and self-test mode.  <a href="#a2b135cd444c2970e16ee8f967399b367">More...</a><br/></td></tr>
<tr class="separator:a2b135cd444c2970e16ee8f967399b367"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0f03e490201c43f19716f90eb9361c19"><td class="memItemLeft" align="right" valign="top">mpu_bus_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a0f03e490201c43f19716f90eb9361c19">bus</a></td></tr>
<tr class="memdesc:a0f03e490201c43f19716f90eb9361c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communication bus pointer, I2C / SPI.  <a href="#a0f03e490201c43f19716f90eb9361c19">More...</a><br/></td></tr>
<tr class="separator:a0f03e490201c43f19716f90eb9361c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b6d939170bf05316efd09e2b669dc1"><td class="memItemLeft" align="right" valign="top">mpu_addr_handle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ab2b6d939170bf05316efd09e2b669dc1">addr</a></td></tr>
<tr class="memdesc:ab2b6d939170bf05316efd09e2b669dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C address / SPI device handle.  <a href="#ab2b6d939170bf05316efd09e2b669dc1">More...</a><br/></td></tr>
<tr class="separator:ab2b6d939170bf05316efd09e2b669dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80be74e486a54e2014bb8a5824e7ca7d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#a80be74e486a54e2014bb8a5824e7ca7d">buffer</a> [16]</td></tr>
<tr class="memdesc:a80be74e486a54e2014bb8a5824e7ca7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commom buffer for temporary data.  <a href="#a80be74e486a54e2014bb8a5824e7ca7d">More...</a><br/></td></tr>
<tr class="separator:a80be74e486a54e2014bb8a5824e7ca7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98c4de6b93d55fc0f0986e963c47c7c"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpud_1_1MPU.html#ad98c4de6b93d55fc0f0986e963c47c7c">err</a></td></tr>
<tr class="memdesc:ad98c4de6b93d55fc0f0986e963c47c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds last error code.  <a href="#ad98c4de6b93d55fc0f0986e963c47c7c">More...</a><br/></td></tr>
<tr class="separator:ad98c4de6b93d55fc0f0986e963c47c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Motion Processing Unit. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae29b235301395c9842d962936ea96f95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpud::MPU::MPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Constructor. </p>

</div>
</div>
<a class="anchor" id="a89b67d15cdc0a41df0516fe350b6fb77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpud::MPU::MPU </td>
          <td>(</td>
          <td class="paramtype">mpu_bus_t &amp;&#160;</td>
          <td class="paramname"><em>bus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contruct a <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a> in the given communication bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>Bus protocol object of type <code>I2Cbus</code> or <code>SPIbus</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04961949e7055540e5e94f3bd96901e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpud::MPU::MPU </td>
          <td>(</td>
          <td class="paramtype">mpu_bus_t &amp;&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpu_addr_handle_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a> in the given communication bus and address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>Bus protocol object of type <code>I2Cbus</code> or <code>SPIbus</code>. </td></tr>
    <tr><td class="paramname">addr</td><td>I2C address (<code>mpu_i2caddr_t</code>) or SPI device handle (<code>spi_device_handle_t</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4158daa85e9a1121cd8d042489ccdfb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpud::MPU::~MPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Destructor, does nothing. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2cbd3a9a7e3ba89f010db63603553502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::acceleration </td>
          <td>(</td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>accel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read accelerometer raw data. </p>

</div>
</div>
<a class="anchor" id="a07e61ca6aeabdab1c16d22e13100110c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::acceleration </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read accelerometer raw data. </p>

</div>
</div>
<a class="anchor" id="a7abdca74a2aa34f8aa3f89e4399a7d35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::accelSelfTest </td>
          <td>(</td>
          <td class="paramtype">raw_axes_t &amp;&#160;</td>
          <td class="paramname"><em>regularBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_axes_t &amp;&#160;</td>
          <td class="paramname"><em>selfTestBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accel Self-test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>self-test error for each axis (X=bit0, Y=bit1, Z=bit2). Zero is a pass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Bias should be in 16G format for MPU6050 and 2G for MPU6500 based models. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3e1c9a1392f875e03144145b3647e8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::auxI2CReadByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>devAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single byte frome slave just once (use for configuring a slave at initialization). </p>
<p>This function uses Slave 4 to perform single transfers to the slave device on Aux I2C. <br/>
The byte will be transfered at first sample take, so when sample rate is at minimum (4 Hz) it may take up to a quarter of a second to start the transfer. </p>
<dl class="section attention"><dt>Attention</dt><dd>Auxiliary I2C Master must have already been configured before calling this function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_ERR_INVALID_STATE Auxiliary I2C Master not enabled;</li>
<li>ESP_ERR_NOT_FOUND Slave doesn't ACK the transfer;</li>
<li>ESP_FAIL Auxiliary I2C Master lost arbitration of the bus;</li>
<li>or other standard I2C driver error codes. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab68de8f658162f624f0f6437b4b00663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::auxI2CWriteByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>devAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to a slave a single byte just once (use for configuring a slave at initialization). </p>
<p>This function uses Slave 4 to perform single transfers to the slave device on Aux I2C. <br/>
The byte will be transfered at first sample take, so when sample rate is at minimum (4 Hz) it may take up to a quarter of a second to start the transfer. </p>
<dl class="section attention"><dt>Attention</dt><dd>Auxiliary I2C Master must have already been configured before calling this function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>ESP_ERR_INVALID_STATE</code>: Auxiliary I2C Master not enabled;</li>
<li><code>ESP_ERR_NOT_FOUND</code>: Slave doesn't ACK the transfer;</li>
<li><code>ESP_FAIL</code>: Auxiliary I2C Master lost arbitration of the bus;</li>
<li>or other standard I2C driver error codes. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="abce2b215567a244643f12c777d4cd2fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::compassGetAdjustment </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Magnetometer's sensitivity adjustment data for each axis. </p>

</div>
</div>
<a class="anchor" id="ace4f070f64dfc38a228e57da16ed989f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpud::MPU::compassGetInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return value from magnetometer's INFO register. </p>

</div>
</div>
<a class="anchor" id="ad93c745f1e13880e5b8b76f67348654b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mag_mode_t mpud::MPU::compassGetMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return magnetometer's measurement mode. </p>

</div>
</div>
<a class="anchor" id="ad08816e89273e50e065cf0fe9dbb6cc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mag_sensy_t mpud::MPU::compassGetSensitivity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return magnetometer sensitivity. </p>

</div>
</div>
<a class="anchor" id="ad630f8c5b4530723a71e299c66403f58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::compassInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize Magnetometer sensor. </p>
<p>Initial configuration:</p>
<ul>
<li>Mode: single measurement (permits variable sample rate).</li>
<li>Sensitivity: 0.15 uT/LSB = 16-bit output.</li>
</ul>
<p>To disable the compass, call compassSetMode(MAG_MODE_POWER_DOWN). </p>

</div>
</div>
<a class="anchor" id="a89a6478e08168bdb203fd5461ab5ee54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::compassReadByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single byte from magnetometer. </p>
<p>How it's done: <br/>
It will check the communication protocol which the <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a> is connected by.</p>
<ul>
<li>I2C, Auxiliary I2C bus will set to bypass mode and the reading will be performed directly (faster).</li>
<li>SPI, the function will use Slave 4 of Auxiliary I2C bus to read the byte (slower). </li>
</ul>

</div>
</div>
<a class="anchor" id="ae438a779cc34c2ba9ad82c816d68cf67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::compassReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Soft reset AK8963. </p>

</div>
</div>
<a class="anchor" id="aa8b7bde480912722eae7ae74969eb8b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpud::MPU::compassSelfTest </td>
          <td>(</td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>result</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform Compass self-test. </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>Not fully functional yet. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Elaborate comment. Add more <code>tries</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a48d2ede5f5efb04d571887294009984b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::compassSetMode </td>
          <td>(</td>
          <td class="paramtype">mag_mode_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change magnetometer's measurement mode. </p>
<dl class="section note"><dt>Note</dt><dd>Setting to MAG_MODE_POWER_DOWN will disable readings from compass and disable (free) Aux I2C slaves 0 and 1. <b>It will not disable Aux I2C Master I/F though!</b> To enable back, use <a class="el" href="classmpud_1_1MPU.html#ad630f8c5b4530723a71e299c66403f58" title="Initialize Magnetometer sensor. ">compassInit()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="afbb1c4afbadabed3d5d730a494fc2f8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::compassSetSensitivity </td>
          <td>(</td>
          <td class="paramtype">mag_sensy_t&#160;</td>
          <td class="paramname"><em>sensy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set magnetometer sensitivity. </p>
<p>Options:</p>
<ul>
<li><code>MAG_SENSITIVITY_0_6_uT</code>: 0.6 uT/LSB = 14-bit output</li>
<li><code>MAG_SENSITIVITY_0_15_uT</code>: 0.15 uT/LSB = 16-bit output </li>
</ul>

</div>
</div>
<a class="anchor" id="a72c7fca29923e1e1b0938df3d5162802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::compassTestConnection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test connection with Magnetometer by checking WHO_I_AM register. </p>

</div>
</div>
<a class="anchor" id="a29f6872c40bbe0a2d697788816f3fd43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpud::MPU::compassWhoAmI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return value from WHO_I_AM register. </p>
<p>Should be <code>0x48</code> for AK8963 and AK8975. </p>

</div>
</div>
<a class="anchor" id="aecfb188d4068287d2cb47868c24ffde6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::compassWriteByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single byte to magnetometer. </p>
<p>How it's done: <br/>
It will check the communication protocol which the <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a> is connected by.</p>
<ul>
<li>I2C, Auxiliary I2C bus will set to bypass mode and the reading will be performed directly (faster).</li>
<li>SPI, the function will use Slave 4 of Auxiliary I2C bus to read the byte (slower). </li>
</ul>

</div>
</div>
<a class="anchor" id="a90d921360cf1c516a0096dfa26997a12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::computeOffsets </td>
          <td>(</td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>accel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>gyro</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Accelerometer and Gyroscope offsets. </p>
<p>This takes about ~400ms to compute offsets. When calculating the offsets the <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a> must remain as horizontal as possible (0 degrees), facing up. It is better to call <a class="el" href="classmpud_1_1MPU.html#a90d921360cf1c516a0096dfa26997a12" title="Compute Accelerometer and Gyroscope offsets. ">computeOffsets()</a> before any configuration is done (better right after <a class="el" href="classmpud_1_1MPU.html#abf4ec47b5cddc47b1bf640d18f1f6e03" title="Initialize MPU device and set basic configurations. ">initialize()</a>).</p>
<p>Note: Gyro offset output are LSB in 1000DPS format. Note: Accel offset output are LSB in 16G format. </p>

</div>
</div>
<a class="anchor" id="a2b57a8867f81fa002cbd3a3e6f27a793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">accel_fs_t mpud::MPU::getAccelFullScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Accelerometer Full-scale range. </p>

</div>
</div>
<a class="anchor" id="ad3ed2e3240d6e1c833a126dbdd40a3cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_axes_t mpud::MPU::getAccelOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return biases from accel offset registers. </p>
<p>This returns the biases with OTP values from factory trim added, so returned values will be different than that ones set with <a class="el" href="classmpud_1_1MPU.html#ada55825eff00782af864b8eea324d148" title="Push biases to the accel offset registers. ">setAccelOffset()</a>.</p>
<p>Note: Bias output are LSB in +-16G format. </p>

</div>
</div>
<a class="anchor" id="a3bbc68bfe24ba563917875239e8d5bca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpu_addr_handle_t mpud::MPU::getAddr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return I2C address or SPI device handle. </p>

</div>
</div>
<a class="anchor" id="a16214d20e471966b8310889382e6245c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpud::MPU::getAuxI2CBypass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Auxiliary I2C Master bypass mode state. </p>

</div>
</div>
<a class="anchor" id="a31b707dd2b97ebbeae3b8fe77b8f9892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auxi2c_config_t mpud::MPU::getAuxI2CConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Auxiliary I2C Master configuration. </p>

</div>
</div>
<a class="anchor" id="ac66b29fca8dc95046925cd0fb834c3ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpud::MPU::getAuxI2CEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Auxiliary I2C Master state. </p>

</div>
</div>
<a class="anchor" id="a3ec47c3742cd89130e8d4952a91ba965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auxi2c_slv_config_t mpud::MPU::getAuxI2CSlaveConfig </td>
          <td>(</td>
          <td class="paramtype">auxi2c_slv_t&#160;</td>
          <td class="paramname"><em>slave</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return configuration of a Aux I2C Slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slave</td><td>slave number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae1fbbbcab82a4894fb91cbfd8452dff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpud::MPU::getAuxI2CSlaveEnabled </td>
          <td>(</td>
          <td class="paramtype">auxi2c_slv_t&#160;</td>
          <td class="paramname"><em>slave</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return enable state of a Aux I2C's Slave. </p>

</div>
</div>
<a class="anchor" id="a8fc5f97dd6e1540a8f61fb5cc38f3b1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auxi2c_stat_t mpud::MPU::getAuxI2CStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Auxiliary I2C Master status from register I2C_MST_STATUS. </p>
<p>Reading this register clear all its bits. </p>

</div>
</div>
<a class="anchor" id="ab7e7f255e90a2238dfc174a4f9fb6f78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auxvddio_lvl_t mpud::MPU::getAuxVDDIOLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return MPU-6050’s I/O logic levels. </p>

</div>
</div>
<a class="anchor" id="a2b135cd444c2970e16ee8f967399b367"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::getBiases </td>
          <td>(</td>
          <td class="paramtype">accel_fs_t&#160;</td>
          <td class="paramname"><em>accelFS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gyro_fs_t&#160;</td>
          <td class="paramname"><em>gyroFS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>accelBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>gyroBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>selftest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Biases in regular mode and self-test mode. </p>
<dl class="section attention"><dt>Attention</dt><dd>When calculating the biases the <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a> must remain as horizontal as possible (0 degrees), facing up. This algorithm takes about ~400ms to compute offsets. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5a067ee1144f7fd2535d787174b34d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpu_bus_t &amp; mpud::MPU::getBus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return communication bus object. </p>

</div>
</div>
<a class="anchor" id="a0e837de0c4e3295b23fc3795a6d7a4c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clock_src_t mpud::MPU::getClockSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return clock source. </p>

</div>
</div>
<a class="anchor" id="ab00fa4ebabb30fd38b8e5a934831c0a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dlpf_t mpud::MPU::getDigitalLowPassFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Digital Low Pass Filter configuration. </p>

</div>
</div>
<a class="anchor" id="a16889bbacbe873f5c8c5c7f0a64c1ec2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fchoice_t mpud::MPU::getFchoice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return FCHOICE. </p>

</div>
</div>
<a class="anchor" id="a03d2e8538b9bee088cd24a8ed96696f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fifo_config_t mpud::MPU::getFIFOConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return FIFO configuration. </p>

</div>
</div>
<a class="anchor" id="a0a0163f781232d7999de4b3d471f6166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpud::MPU::getFIFOCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of written bytes in the FIFO. </p>
<dl class="section note"><dt>Note</dt><dd>FIFO overflow generates an interrupt which can be check with <a class="el" href="classmpud_1_1MPU.html#a09235a4fda5e67181f5955e144d650fe" title="Return the Interrupt status from INT_STATUS register. ">getInterruptStatus()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a245641aa976568a0ef57ea8f5a455755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpud::MPU::getFIFOEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return FIFO module state. </p>

</div>
</div>
<a class="anchor" id="a7e509f6284e00539cdb3745940902f73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fifo_mode_t mpud::MPU::getFIFOMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return FIFO mode. </p>

</div>
</div>
<a class="anchor" id="a3f5928c0ec1dced316a4cc97b65f8bf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ff_config_t mpud::MPU::getFreeFallConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Free-Fall Configuration. </p>

</div>
</div>
<a class="anchor" id="ad2482624d04492e84647953469dce5cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_lvl_t mpud::MPU::getFsyncConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return FSYNC pin active level configuration. </p>

</div>
</div>
<a class="anchor" id="a98bafda6d35ea1b84f689b61b93f3459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpud::MPU::getFsyncEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return FSYNC enable state. </p>

</div>
</div>
<a class="anchor" id="a9617adda4ad6b567564530a4e30854ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gyro_fs_t mpud::MPU::getGyroFullScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Gyroscope Full-scale range. </p>

</div>
</div>
<a class="anchor" id="a2370fc876d7f4e2f411d7a7e500a05f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_axes_t mpud::MPU::getGyroOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return biases from the gyro offset registers. </p>
<p>Note: Bias output are LSB in +-1000dps format. </p>

</div>
</div>
<a class="anchor" id="a06b73dd1c899e8b8d49f01a51323f3aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_config_t mpud::MPU::getInterruptConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Interrupt pin (INT) configuration. </p>

</div>
</div>
<a class="anchor" id="aedabde55ce93c78db203d1691aed5387"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_en_t mpud::MPU::getInterruptEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return enabled features configured to generate signal at Interrupt pin. </p>

</div>
</div>
<a class="anchor" id="a09235a4fda5e67181f5955e144d650fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_stat_t mpud::MPU::getInterruptStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Interrupt status from INT_STATUS register. </p>
<p>Note: Reading this register, clear all bits. </p>

</div>
</div>
<a class="anchor" id="a06b209b83d102efbefa31652d7c7ab44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpud::MPU::getLowPowerAccelMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Low Power Accelerometer state. </p>
<p>Condition to return true:</p>
<ul>
<li>CYCLE bit is 1</li>
<li>SLEEP bit is 0</li>
<li>TEMP_DIS bit is 1</li>
<li>STBY_XG, STBY_YG, STBY_ZG bits are 1</li>
<li>STBY_XA, STBY_YA, STBY_ZA bits are 0</li>
<li>FCHOICE is 0 (ACCEL_FCHOICE_B bit is 1) [MPU6500 / MPU9250 only] </li>
</ul>

</div>
</div>
<a class="anchor" id="ab4ccd9930f45bf7d7f846669faaa6470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lp_accel_rate_t mpud::MPU::getLowPowerAccelRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Low Power Accelerometer frequency of wake-up. </p>

</div>
</div>
<a class="anchor" id="a8b7ddfc203bfcad9526fe44b126cf558"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mot_config_t mpud::MPU::getMotionDetectConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Motion Detection Configuration. </p>

</div>
</div>
<a class="anchor" id="a690d1e11d03a37182c6c82685e86614e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mot_stat_t mpud::MPU::getMotionDetectStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Motion Detection Status. </p>
<dl class="section note"><dt>Note</dt><dd>Reading this register clears all motion detection status bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e9be65d55d154aed34bd6d24858c6b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpud::MPU::getMotionFeatureEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if a Motion Dectection module is enabled. </p>

</div>
</div>
<a class="anchor" id="ad100efa072bb68c2b910d5f7c8f01025"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpud::MPU::getSampleRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve sample rate divider and calculate the actual rate. </p>

</div>
</div>
<a class="anchor" id="aeddfb49d62323ff4dd4d3b5dfc389217"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpud::MPU::getSleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current sleep state. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code>: sleep enabled.</li>
<li><code>false</code>: sleep disabled. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4e5d207e7ac4d063af14c343acb25e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stby_en_t mpud::MPU::getStandbyMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Standby configuration. </p>

</div>
</div>
<a class="anchor" id="acc14bfa64a079c9fa9cdc0754bc6a6ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">zrmot_config_t mpud::MPU::getZeroMotionConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Zero-Motion configuration. </p>

</div>
</div>
<a class="anchor" id="a8ccea2636c90a078bd5101ad0e5d463a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::gyroSelfTest </td>
          <td>(</td>
          <td class="paramtype">raw_axes_t &amp;&#160;</td>
          <td class="paramname"><em>regularBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_axes_t &amp;&#160;</td>
          <td class="paramname"><em>selfTestBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gyro Self-test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Self-test error for each axis (X=bit0, Y=bit1, Z=bit2). Zero is a pass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Bias should be in 250DPS format for both MPU6050 and MPU6500 based models. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dd6954c3a01beef7a20412d081ea52d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::heading </td>
          <td>(</td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>mag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read compass data. </p>

</div>
</div>
<a class="anchor" id="a8e22412e9a313663a3f0489f6e90c6d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::heading </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read compass data. </p>

</div>
</div>
<a class="anchor" id="abf4ec47b5cddc47b1bf640d18f1f6e03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a> device and set basic configurations. </p>
<p>Init configuration:</p>
<ul>
<li>Accel FSR: 4G</li>
<li>Gyro FSR: 500DPS</li>
<li>Sample rate: 100Hz</li>
<li>DLPF: 42Hz</li>
<li>INT pin: disabled</li>
<li>FIFO: disabled</li>
<li>Clock source: gyro PLL For MPU9150 and MPU9250:</li>
<li>Aux I2C Master: enabled, clock: 400KHz</li>
<li>Compass: enabled on Aux I2C's Slave 0 and Slave 1</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>A soft reset is performed first, which takes 100-200ms.</li>
<li>When using SPI, the primary I2C Slave module is disabled right away. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7dc571c795e7675a7e581e9de3132423"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::lastError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return last error code. </p>

</div>
</div>
<a class="anchor" id="ae10cea57d72889dfaec9d4945458fd26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::motion </td>
          <td>(</td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>accel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>gyro</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read accelerometer and gyroscope data at once. </p>

</div>
</div>
<a class="anchor" id="a4e4984659aea9520de50c63732683cca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::motion </td>
          <td>(</td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>accel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>gyro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>mag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read accelerometer, gyroscope, compass raw data. </p>

</div>
</div>
<a class="anchor" id="af11434db963024c65bbc2d1af0adcdcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::readAuxI2CRxData </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>skip</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from slaves connected to Auxiliar I2C bus. </p>
<p>Data is placed in these external sensor data registers according to I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_CTRL (Registers 39, 42, 45, and 48). When more than zero bytes are read (I2C_SLVx_LEN &gt; 0) from an enabled slave (I2C_SLVx_EN = 1), the slave is read at the Sample Rate (as defined in Register 25) or delayed rate (if specified in Register 52 and 103). During each sample cycle, slave reads are performed in order of Slave number. If all slaves are enabled with more than zero bytes to be read, the order will be Slave 0, followed by Slave 1, Slave 2, and Slave 3.</p>
<p>If the sum of the read lengths of all SLVx transactions exceed the number of available EXT_SENS_DATA registers, the excess bytes will be dropped. There are 24 EXT_SENS_DATA registers and hence the total read lengths between all the slaves cannot be greater than 24 or some bytes will be lost.</p>
<dl class="section attention"><dt>Attention</dt><dd>Set <code>skip</code> to <code>8</code> when using compass, because compass data takes up the first <code>8</code> bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ae96fcd85fb8984a648a537652628aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::readBit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single bit from a register. </p>

</div>
</div>
<a class="anchor" id="a72149421a41df3c7a3a4834262d96799"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::readBits </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a range of bits from a register. </p>

</div>
</div>
<a class="anchor" id="ad3d8b3b65e360bad7cf0ef9303e060df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::readByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single register. </p>

</div>
</div>
<a class="anchor" id="ab105d924a8077595f55ef639ffd49c54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::readBytes </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from sequence of registers. </p>

</div>
</div>
<a class="anchor" id="ada674500740290d24050a5977a278cf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::readFIFO </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data contained in FIFO buffer. </p>

</div>
</div>
<a class="anchor" id="a0c78483b51cade734c6aa4d0c1ba4260"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::registerDump </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0x0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>end</em> = <code>0x7F</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out register values for debugging purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>first register number. </td></tr>
    <tr><td class="paramname">end</td><td>last register number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac816b0c7f9c347e96a4b87bf9280d366"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset internal registers and restore to default start-up state. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function delays 100ms when using I2C and 200ms when using SPI.</li>
<li>It does not initialize the <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a> again, just call <a class="el" href="classmpud_1_1MPU.html#abf4ec47b5cddc47b1bf640d18f1f6e03" title="Initialize MPU device and set basic configurations. ">initialize()</a> instead. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac179cdbbb90e610a235ebf5060511c94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::resetFIFO </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset FIFO module. </p>
<p>Zero FIFO count, reset is asynchronous. <br/>
The bit auto clears after one clock cycle. </p>

</div>
</div>
<a class="anchor" id="ad4c2fceb9b73753b7a1e64830eee2bff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::resetSignalPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset sensors signal path. </p>
<p>Reset all gyro digital signal path, accel digital signal path, and temp digital signal path. This also clears all the sensor registers.</p>
<dl class="section note"><dt>Note</dt><dd>This function delays 100 ms, needed for reset to complete. </dd></dl>

</div>
</div>
<a class="anchor" id="ae50185e00fdc4f8cc0eda07237413a0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::restartAuxI2C </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart Auxiliary I2C Master module, reset is asynchronous. </p>
<p>This bit (I2C_MST_RST) should only be set when the I2C master has hung. If this bit is set during an active I2C master transaction, the I2C slave will hang, which will require the host to reset the slave. </p>

</div>
</div>
<a class="anchor" id="a9a3867483a0ab5e6ad49d244f5c5bc7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::rotation </td>
          <td>(</td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>gyro</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read gyroscope raw data. </p>

</div>
</div>
<a class="anchor" id="aa9f2053319e684514aab21f93964195b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::rotation </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read gyroscope raw data. </p>

</div>
</div>
<a class="anchor" id="ab2ea9e17d5eded6f6fc1c571b5adf09a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::selfTest </td>
          <td>(</td>
          <td class="paramtype">selftest_t *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger gyro and accel hardware self-test. </p>
<dl class="section attention"><dt>Attention</dt><dd>when calling this function, the <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a> must remain as horizontal as possible (0 degrees), facing up. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Should be ZERO if gyro and accel passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Elaborate doc. </dd></dl>

</div>
</div>
<a class="anchor" id="a5706267bee5220d4003968a1d03c26d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::sensors </td>
          <td>(</td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>accel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_axes_t *&#160;</td>
          <td class="paramname"><em>gyro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from all internal sensors. </p>

</div>
</div>
<a class="anchor" id="a248f2e18edc94d307fda175669659951"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::sensors </td>
          <td>(</td>
          <td class="paramtype">sensors_t *&#160;</td>
          <td class="paramname"><em>sensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>extsens_len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from all sensors, including external sensors in Aux I2C. </p>

</div>
</div>
<a class="anchor" id="a8f50e9f28b6d5e0a03ab5d982b003d7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setAccelFullScale </td>
          <td>(</td>
          <td class="paramtype">accel_fs_t&#160;</td>
          <td class="paramname"><em>fsr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select Accelerometer Full-scale range. </p>

</div>
</div>
<a class="anchor" id="ada55825eff00782af864b8eea324d148"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setAccelOffset </td>
          <td>(</td>
          <td class="paramtype">raw_axes_t&#160;</td>
          <td class="paramname"><em>bias</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push biases to the accel offset registers. </p>
<p>This function expects biases relative to the current sensor output, and these biases will be added to the factory-supplied values.</p>
<p>Note: Bias inputs are LSB in +-16G format. </p>

</div>
</div>
<a class="anchor" id="a239ee099bcc9d010622ab87e0309d742"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpud_1_1MPU.html">MPU</a> &amp; mpud::MPU::setAddr </td>
          <td>(</td>
          <td class="paramtype">mpu_addr_handle_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set I2C address or SPI device handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>I2C address (<code>mpu_i2caddr_t</code>) or SPI device handle (<code>spi_device_handle_t</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a234737d60a59bc91847e8c1efc09d0d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setAuxI2CBypass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / disable Auxiliary I2C bypass mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td><ul>
<li><code>true</code>: Auxiliar I2C Master I/F is disabled, and Bypass enabled.</li>
<li><code>false</code>: Bypass is disabled, but the Auxiliar I2C Master I/F is not enabled back, if needed, enabled it again with setAuxI2CmasterEnabled(). </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80fb7650a035eac4ca21c73af61584b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setAuxI2CConfig </td>
          <td>(</td>
          <td class="paramtype">const auxi2c_config_t &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the Auxiliary I2C Master. </p>
<dl class="section note"><dt>Note</dt><dd>For [MPU9150, MPU9250]: The Auxiliary I2C is configured in the initialization stage to connect with the compass in Slave 0 and Slave 1. </dd></dl>

</div>
</div>
<a class="anchor" id="a7dc70b0f6fbbc924458fbea7a6a4e445"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setAuxI2CEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / disable Auxiliary I2C Master module. </p>

</div>
</div>
<a class="anchor" id="a5d59d8d47005a54d3b596aa95ae6ecb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setAuxI2CSlaveConfig </td>
          <td>(</td>
          <td class="paramtype">const auxi2c_slv_config_t &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure communication with a Slave connected to Auxiliary I2C bus. </p>

</div>
</div>
<a class="anchor" id="ae0daae48cac088da3f3f82472fd56410"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setAuxI2CSlaveEnabled </td>
          <td>(</td>
          <td class="paramtype">auxi2c_slv_t&#160;</td>
          <td class="paramname"><em>slave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the Auxiliary I2C module to transfer data with a slave at sample rate. </p>

</div>
</div>
<a class="anchor" id="aedfad2954a2039babb7a47e249858b34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setAuxVDDIOLevel </td>
          <td>(</td>
          <td class="paramtype">auxvddio_lvl_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The MPU-6050’s I/O logic levels are set to be either VDD or VLOGIC. </p>
<p>VLOGIC may be set to be equal to VDD or to another voltage. However, VLOGIC must be ≤ VDD at all times. When AUX_VDDIO is set to 0 (its power-on-reset value), VLOGIC is the power supply voltage for both the microprocessor system bus and the auxiliary I C bus. When AUX_VDDIO is set to 1, VLOGIC is the power supply voltage for the microprocessor system bus and VDD is the supply for the auxiliary I2C bus </p>

</div>
</div>
<a class="anchor" id="a6141d67b7fd4188b26832a4e15471940"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpud_1_1MPU.html">MPU</a> &amp; mpud::MPU::setBus </td>
          <td>(</td>
          <td class="paramtype">mpu_bus_t &amp;&#160;</td>
          <td class="paramname"><em>bus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set communication bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>Bus protocol object of type <code>I2Cbus</code> or <code>SPIbus</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af792064f923921167a1385197d18fb10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setClockSource </td>
          <td>(</td>
          <td class="paramtype">clock_src_t&#160;</td>
          <td class="paramname"><em>clockSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select clock source. </p>
<dl class="section note"><dt>Note</dt><dd>The gyro PLL is better than internal clock. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clockSrc</td><td>clock source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93430f192fea612abf036ba3729ba844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setDigitalLowPassFilter </td>
          <td>(</td>
          <td class="paramtype">dlpf_t&#160;</td>
          <td class="paramname"><em>dlpf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures Digital Low Pass Filter (DLPF) setting for both the gyroscope and accelerometer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlpf</td><td>digital low-pass filter value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ef778fb0d9363b3a473ed87270fb0af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setFchoice </td>
          <td>(</td>
          <td class="paramtype">fchoice_t&#160;</td>
          <td class="paramname"><em>fchoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select FCHOICE. </p>
<p>Dev note: FCHOICE is the inverted value of FCHOICE_B (e.g. FCHOICE=2b’00 is same as FCHOICE_B=2b’11). Reset value is FCHOICE_3 </p>

</div>
</div>
<a class="anchor" id="aeccb3e80bee7ce275ce21c7d14658496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setFIFOConfig </td>
          <td>(</td>
          <td class="paramtype">fifo_config_t&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the sensors that will be written to the FIFO. </p>

</div>
</div>
<a class="anchor" id="a047d9014f1cbcdab1820e6e9ab398cf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setFIFOEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enabled / disable FIFO module. </p>

</div>
</div>
<a class="anchor" id="af0e0ccb076f70cdb5cc0b60da43294c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setFIFOMode </td>
          <td>(</td>
          <td class="paramtype">fifo_mode_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change FIFO mode. </p>
<p>Options: <code>FIFO_MODE_OVERWRITE</code>: When the fifo is full, additional writes will be written to the fifo,replacing the oldest data. <code>FIFO_MODE_STOP_FULL</code>: When the fifo is full, additional writes will not be written to fifo. </p>

</div>
</div>
<a class="anchor" id="ad5de2361bde9aff3cbd069dfa319ca11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setFreeFallConfig </td>
          <td>(</td>
          <td class="paramtype">ff_config_t &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure Free-Fall. </p>
<p>Free fall is detected by checking if the accelerometer measurements from all 3 axes have an absolute value below a user-programmable threshold (acceleration threshold). For each sample where this condition is true (a qualifying sample), a counter is incremented. For each sample where this condition is false (a non- qualifying sample), the counter is decremented. Once the counter reaches a user-programmable threshold (the counter threshold), the Free Fall interrupt is triggered and a flag is set. The flag is cleared once the counter has decremented to zero. The counter does not increment above the counter threshold or decrement below zero.</p>
<dl class="section note"><dt>Note</dt><dd>Enable by calling <a class="el" href="classmpud_1_1MPU.html#aa79f7156514ab8f38db1dba7e3ee2931" title="Enable/disable Motion modules (Motion detect, Zero-motion, Free-Fall). ">setMotionFeatureEnabled()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8ad215220b07819692624334ce6d4d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setFsyncConfig </td>
          <td>(</td>
          <td class="paramtype">int_lvl_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the active level of FSYNC pin that will cause an interrupt. </p>
<p>Use <a class="el" href="classmpud_1_1MPU.html#aa2d3408f13d9889c719d31bf3b59b316" title="Enable / disable FSYNC pin to cause an interrupt. ">setFsyncEnabled()</a> to enable / disable this interrupt. </p>

</div>
</div>
<a class="anchor" id="aa2d3408f13d9889c719d31bf3b59b316"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setFsyncEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / disable FSYNC pin to cause an interrupt. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The interrupt status is located in I2C_MST_STATUS register, so use the method <a class="el" href="classmpud_1_1MPU.html#a8fc5f97dd6e1540a8f61fb5cc38f3b1d" title="Return Auxiliary I2C Master status from register I2C_MST_STATUS. ">getAuxI2CStatus()</a> which reads this register to get FSYNC status. Keep in mind that a read from I2C_MST_STATUS register clears all its status bits, so take care to miss status bits when using Auxiliary I2C bus too.</li>
<li>It is possible to enable the FSYNC interrupt propagate to INT pin with <a class="el" href="classmpud_1_1MPU.html#a7d1c909c89a49e3b6c7916eaf94fd621" title="Enable features to generate signal at Interrupt pin. ">setInterruptEnabled()</a>, then the status can also be read with <a class="el" href="classmpud_1_1MPU.html#a09235a4fda5e67181f5955e144d650fe" title="Return the Interrupt status from INT_STATUS register. ">getInterruptStatus()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmpud_1_1MPU.html#ae8ad215220b07819692624334ce6d4d8" title="Configure the active level of FSYNC pin that will cause an interrupt. ">setFsyncConfig()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2868752f20d013cb21e99ecd7592a05f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setGyroFullScale </td>
          <td>(</td>
          <td class="paramtype">gyro_fs_t&#160;</td>
          <td class="paramname"><em>fsr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select Gyroscope Full-scale range. </p>

</div>
</div>
<a class="anchor" id="aa4aae2cc95bdf261c87fcc8b5eb65af2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setGyroOffset </td>
          <td>(</td>
          <td class="paramtype">raw_axes_t&#160;</td>
          <td class="paramname"><em>bias</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push biases to the gyro offset registers. </p>
<p>This function expects biases relative to the current sensor output, and these biases will be added to the factory-supplied values.</p>
<p>Note: Bias inputs are LSB in +-1000dps format. </p>

</div>
</div>
<a class="anchor" id="aca375de0ab565d6b29b3b5da05f4b784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setInterruptConfig </td>
          <td>(</td>
          <td class="paramtype">int_config_t&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the Interrupt pin (INT). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>configuration desired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d1c909c89a49e3b6c7916eaf94fd621"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setInterruptEnabled </td>
          <td>(</td>
          <td class="paramtype">int_en_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable features to generate signal at Interrupt pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>ORed features. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae518ddb48624a5a9b664c3c86a2c2759"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setLowPowerAccelMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter Low Power Accelerometer mode. </p>
<p>In low-power accel mode, the chip goes to sleep and only wakes up to sample the accelerometer at a certain frequency. See <a class="el" href="classmpud_1_1MPU.html#afa2886c024e5239d67ea8fff668e734d" title="Set Low Power Accelerometer frequency of wake-up. ">setLowPowerAccelRate()</a> to set the frequency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>value<ul>
<li>This function does the following to enable:<ul>
<li>Set CYCLE bit to 1</li>
<li>Set SLEEP bit to 0</li>
<li>Set TEMP_DIS bit to 1</li>
<li>Set STBY_XG, STBY_YG, STBY_ZG bits to 1</li>
<li>Set STBY_XA, STBY_YA, STBY_ZA bits to 0</li>
<li>Set FCHOICE to 0 (ACCEL_FCHOICE_B bit to 1) [MPU6500 / MPU9250 only]</li>
<li>Disable Auxiliary I2C Master I/F</li>
</ul>
</li>
<li>This function does the following to disable:<ul>
<li>Set CYCLE bit to 0</li>
<li>Set TEMP_DIS bit to 0</li>
<li>Set STBY_XG, STBY_YG, STBY_ZG bits to 0</li>
<li>Set STBY_XA, STBY_YA, STBY_ZA bits to 0</li>
<li>Set FCHOICE to 3 (ACCEL_FCHOICE_B bit to 0) [MPU6500 / MPU9250 only]</li>
<li>Enable Auxiliary I2C Master I/F </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa2886c024e5239d67ea8fff668e734d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setLowPowerAccelRate </td>
          <td>(</td>
          <td class="paramtype">lp_accel_rate_t&#160;</td>
          <td class="paramname"><em>rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Low Power Accelerometer frequency of wake-up. </p>

</div>
</div>
<a class="anchor" id="a4f964bb09777e246ab9bc868c7b52ae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setMotionDetectConfig </td>
          <td>(</td>
          <td class="paramtype">mot_config_t &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure Motion-Detect or Wake-on-motion feature. </p>
<p>The behaviour of this feature is very different between the MPU6050 (MPU9150) and the MPU6500 (MPU9250). Each chip's version of this feature is explained below.</p>
<p>[MPU6050, MPU6000, MPU9150]: Accelerometer measurements are passed through a configurable digital high pass filter (DHPF) in order to eliminate bias due to gravity. A qualifying motion sample is one where the high passed sample from any axis has an absolute value exceeding a user-programmable threshold. A counter increments for each qualifying sample, and decrements for each non-qualifying sample. Once the counter reaches a user-programmable counter threshold, a motion interrupt is triggered. The axis and polarity which caused the interrupt to be triggered is flagged in the MOT_DETECT_STATUS register.</p>
<p>[MPU6500, MPU9250]: Unlike the MPU6050 version, the hardware does not "lock in" a reference sample. The hardware monitors the accel data and detects any large change over a short period of time. A qualifying motion sample is one where the high passed sample from any axis has an absolute value exceeding the threshold. The hardware motion threshold can be between 4mg and 1020mg in 4mg increments.</p>
<dl class="section note"><dt>Note</dt><dd>It is possible to enable <b>wake-on-motion</b> mode by doing the following:<ol type="1">
<li>Enter Low Power Accelerometer mode with <a class="el" href="classmpud_1_1MPU.html#ae518ddb48624a5a9b664c3c86a2c2759" title="Enter Low Power Accelerometer mode. ">setLowPowerAccelMode()</a>;</li>
<li>Select the wake-up rate with <a class="el" href="classmpud_1_1MPU.html#afa2886c024e5239d67ea8fff668e734d" title="Set Low Power Accelerometer frequency of wake-up. ">setLowPowerAccelRate()</a>;</li>
<li>Configure motion-detect interrupt with <a class="el" href="classmpud_1_1MPU.html#a4f964bb09777e246ab9bc868c7b52ae0" title="Configure Motion-Detect or Wake-on-motion feature. ">setMotionDetectConfig()</a>;</li>
<li>Enable the motion detection module with <a class="el" href="classmpud_1_1MPU.html#aa79f7156514ab8f38db1dba7e3ee2931" title="Enable/disable Motion modules (Motion detect, Zero-motion, Free-Fall). ">setMotionFeatureEnabled()</a>; </li>
</ol>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa79f7156514ab8f38db1dba7e3ee2931"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setMotionFeatureEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable Motion modules (Motion detect, Zero-motion, Free-Fall). </p>
<dl class="section attention"><dt>Attention</dt><dd>The configurations must've already been set with <a class="el" href="classmpud_1_1MPU.html#a4f964bb09777e246ab9bc868c7b52ae0" title="Configure Motion-Detect or Wake-on-motion feature. ">setMotionDetectConfig()</a> before enabling the module! </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Call <a class="el" href="classmpud_1_1MPU.html#a690d1e11d03a37182c6c82685e86614e" title="Return Motion Detection Status. ">getMotionDetectStatus()</a> to find out which axis generated motion interrupt. [MPU6000, MPU6050, MPU9150].</li>
<li>It is recommended to set the Motion Interrupt to propagate to the INT pin. To do that, use <a class="el" href="classmpud_1_1MPU.html#a7d1c909c89a49e3b6c7916eaf94fd621" title="Enable features to generate signal at Interrupt pin. ">setInterruptEnabled()</a>. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td><ul>
<li>On <em>true</em>, this function modifies the DLPF, put gyro and temperature in standby, and disable Auxiliary I2C Master I/F.</li>
<li>On <em>false</em>, this function sets DLPF to 42Hz and enables Auxiliary I2C master I/F. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65cf0a938a17e4e6b81d9d4625e2d7f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setSampleRate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set sample rate of data output. </p>
<p>Sample rate controls sensor data output rate and FIFO sample rate. This is the update rate of sensor register. <br/>
Formula: Sample Rate = Internal Output Rate / (1 + SMPLRT_DIV)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>4Hz ~ 1KHz<ul>
<li>For sample rate 8KHz: set digital low pass filter to DLPF_256HZ_NOLPF.</li>
<li>For sample rate 32KHZ [MPU6500 / MPU9250]: set fchoice to FCHOICE_0, see <a class="el" href="classmpud_1_1MPU.html#a3ef778fb0d9363b3a473ed87270fb0af" title="Select FCHOICE. ">setFchoice()</a>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For MPU9150 &amp; MPU9250:<ul>
<li>When using compass, this function alters Aux I2C Master <code>sample_delay</code> property to adjust the compass sample rate. (also, <code>wait_for_es</code> property to adjust interrupt).</li>
<li>If sample rate lesser than 100 Hz, data-ready interrupt will wait for compass data.</li>
<li>If sample rate greater than 100 Hz, data-ready interrupt will not be delayed by the compass. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a14ada26485f2936515d07dff156912ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setSleep </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / disable sleep mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>enable value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd07ab02e86337b6bc0841c163320985"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setStandbyMode </td>
          <td>(</td>
          <td class="paramtype">stby_en_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure sensors' standby mode. </p>

</div>
</div>
<a class="anchor" id="a8098999b567e7352b7150df5197f28ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::setZeroMotionConfig </td>
          <td>(</td>
          <td class="paramtype">zrmot_config_t &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure Zero-Motion. </p>
<p>The Zero Motion detection capability uses the digital high pass filter (DHPF) and a similar threshold scheme to that of Free Fall detection. Each axis of the high passed accelerometer measurement must have an absolute value less than a threshold specified in the ZRMOT_THR register, which can be increased in 1 mg increments. Each time a motion sample meets this condition, a counter increments. When this counter reaches a threshold specified in ZRMOT_DUR, an interrupt is generated.</p>
<p>Unlike Free Fall or Motion detection, Zero Motion detection triggers an interrupt both when Zero Motion is first detected and when Zero Motion is no longer detected. While Free Fall and Motion are indicated with a flag which clears after being read, reading the state of the Zero Motion detected from the MOT_DETECT_STATUS register does not clear its status.</p>
<dl class="section note"><dt>Note</dt><dd>Enable by calling <a class="el" href="classmpud_1_1MPU.html#aa79f7156514ab8f38db1dba7e3ee2931" title="Enable/disable Motion modules (Motion detect, Zero-motion, Free-Fall). ">setMotionFeatureEnabled()</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="abae90cd70c7a5d52bc4e591153348e91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::temperature </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>temp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read temperature raw data. </p>

</div>
</div>
<a class="anchor" id="a6d4b1566f17724e1e608357fee52e40e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::testConnection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test connection with <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a>. </p>
<p>It reads the WHO_AM_IM register and check its value against the correct chip model. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>ESP_OK</code>: The <a class="el" href="classmpud_1_1MPU.html" title="Motion Processing Unit. ">MPU</a> is connected and matchs the model.</li>
<li><code>ESP_ERR_NOT_FOUND</code>: A device is connect, but does not match the chip selected in <em>menuconfig</em>.</li>
<li>May return other communication bus errors. e.g: <code>ESP_FAIL</code>, <code>ESP_ERR_TIMEOUT</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afcfeba46e532569acefa3d7e4a1ad7c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpud::MPU::whoAmI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value from WHO_AM_I register. </p>

</div>
</div>
<a class="anchor" id="ad210960077fdbfacd7fa43ba3ca583b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::writeBit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a single bit to a register. </p>

</div>
</div>
<a class="anchor" id="a84f18f4b076105c2c3f9ca4fcdf08f1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::writeBits </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a range of bits to a register. </p>

</div>
</div>
<a class="anchor" id="a79a288c09a9da20cbc1e6d3c9597fe42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::writeByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a value to a register. </p>

</div>
</div>
<a class="anchor" id="aea6ae433dba53a49ee7cc9c239784dff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::writeBytes </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a sequence to data to a sequence of registers. </p>

</div>
</div>
<a class="anchor" id="aaeeddc45a786735b611621d0cfe719b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::writeFIFO </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to FIFO buffer. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ab2b6d939170bf05316efd09e2b669dc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpu_addr_handle_t mpud::MPU::addr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>I2C address / SPI device handle. </p>

</div>
</div>
<a class="anchor" id="a80be74e486a54e2014bb8a5824e7ca7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpud::MPU::buffer[16]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commom buffer for temporary data. </p>

</div>
</div>
<a class="anchor" id="a0f03e490201c43f19716f90eb9361c19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpu_bus_t* mpud::MPU::bus</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Communication bus pointer, I2C / SPI. </p>

</div>
</div>
<a class="anchor" id="ad98c4de6b93d55fc0f0986e963c47c7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t mpud::MPU::err</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Holds last error code. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/travis/build/natanaeljr/esp32-MPU-driver/include/<a class="el" href="MPU_8hpp_source.html">MPU.hpp</a></li>
<li>/home/travis/build/natanaeljr/esp32-MPU-driver/src/<a class="el" href="MPU_8cpp.html">MPU.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
